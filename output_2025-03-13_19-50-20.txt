import { useEffect, useState } from 'react';

export interface ControllerInputs {
  leftStick: { x: number, y: number };
  rightStick: { x: number, y: number };
  leftTrigger: number;
  rightTrigger: number;
  buttons: {
    a: boolean;
    b: boolean;
    x: boolean;
    y: boolean;
    lb: boolean; 
    rb: boolean;
    back: boolean;
    start: boolean;
    leftStickPress: boolean;
    rightStickPress: boolean;
    dpadUp: boolean;
    dpadDown: boolean;
    dpadLeft: boolean;
    dpadRight: boolean;
  };
  connected: boolean;
}

const defaultInputs: ControllerInputs = {
  leftStick: { x: 0, y: 0 },
  rightStick: { x: 0, y: 0 },
  leftTrigger: 0,
  rightTrigger: 0,
  buttons: {
    a: false,
    b: false,
    x: false,
    y: false,
    lb: false,
    rb: false,
    back: false,
    start: false,
    leftStickPress: false,
    rightStickPress: false,
    dpadUp: false,
    dpadDown: false,
    dpadLeft: false,
    dpadRight: false,
  },
  connected: false
};

// Button mapping for Xbox controller (standard mapping)
const BUTTON_MAPPING = {
  A: 0,
  B: 1,
  X: 2,
  Y: 3,
  LB: 4,
  RB: 5,
  LT: 6, // Also accessible as analog
  RT: 7, // Also accessible as analog
  BACK: 8,
  START: 9,
  LEFT_STICK_PRESS: 10,
  RIGHT_STICK_PRESS: 11,
  DPAD_UP: 12,
  DPAD_DOWN: 13,
  DPAD_LEFT: 14,
  DPAD_RIGHT: 15
};

// Controller axes mapping
const AXES_MAPPING = {
  LEFT_STICK_X: 0,
  LEFT_STICK_Y: 1,
  RIGHT_STICK_X: 2,
  RIGHT_STICK_Y: 3
};

export const useXboxController = (deadzone = 0.1): ControllerInputs => {
  const [inputs, setInputs] = useState<ControllerInputs>(defaultInputs);
  
  useEffect(() => {
    const handleGamepadConnected = (event: GamepadEvent) => {
      console.log('Gamepad connected:', event.gamepad.id);
    };
    
    const handleGamepadDisconnected = (event: GamepadEvent) => {
      console.log('Gamepad disconnected:', event.gamepad.id);
      if (isXboxController(event.gamepad)) {
        setInputs(defaultInputs);
      }
    };
    
    window.addEventListener('gamepadconnected', handleGamepadConnected);
    window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);
    
    // Poll for gamepad state
    let animationFrameId: number;
    
    const updateGamepadState = () => {
      const gamepads = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
      const xboxController = gamepads.find(isXboxController);
      
      if (xboxController) {
        const newInputs: ControllerInputs = {
          leftStick: {
            x: applyDeadzone(xboxController.axes[AXES_MAPPING.LEFT_STICK_X], deadzone),
            y: applyDeadzone(xboxController.axes[AXES_MAPPING.LEFT_STICK_Y], deadzone)
          },
          rightStick: {
            x: applyDeadzone(xboxController.axes[AXES_MAPPING.RIGHT_STICK_X], deadzone),
            y: applyDeadzone(xboxController.axes[AXES_MAPPING.RIGHT_STICK_Y], deadzone)
          },
          leftTrigger: xboxController.buttons[BUTTON_MAPPING.LT]?.value || 0,
          rightTrigger: xboxController.buttons[BUTTON_MAPPING.RT]?.value || 0,
          buttons: {
            a: xboxController.buttons[BUTTON_MAPPING.A]?.pressed || false,
            b: xboxController.buttons[BUTTON_MAPPING.B]?.pressed || false,
            x: xboxController.buttons[BUTTON_MAPPING.X]?.pressed || false,
            y: xboxController.buttons[BUTTON_MAPPING.Y]?.pressed || false,
            lb: xboxController.buttons[BUTTON_MAPPING.LB]?.pressed || false,
            rb: xboxController.buttons[BUTTON_MAPPING.RB]?.pressed || false,
            back: xboxController.buttons[BUTTON_MAPPING.BACK]?.pressed || false,
            start: xboxController.buttons[BUTTON_MAPPING.START]?.pressed || false,
            leftStickPress: xboxController.buttons[BUTTON_MAPPING.LEFT_STICK_PRESS]?.pressed || false,
            rightStickPress: xboxController.buttons[BUTTON_MAPPING.RIGHT_STICK_PRESS]?.pressed || false,
            dpadUp: xboxController.buttons[BUTTON_MAPPING.DPAD_UP]?.pressed || false,
            dpadDown: xboxController.buttons[BUTTON_MAPPING.DPAD_DOWN]?.pressed || false,
            dpadLeft: xboxController.buttons[BUTTON_MAPPING.DPAD_LEFT]?.pressed || false,
            dpadRight: xboxController.buttons[BUTTON_MAPPING.DPAD_RIGHT]?.pressed || false,
          },
          connected: true
        };
        
        setInputs(newInputs);
      }
      
      animationFrameId = requestAnimationFrame(updateGamepadState);
    };
    
    animationFrameId = requestAnimationFrame(updateGamepadState);
    
    return () => {
      cancelAnimationFrame(animationFrameId);
      window.removeEventListener('gamepadconnected', handleGamepadConnected);
      window.removeEventListener('gamepaddisconnected', handleGamepadDisconnected);
    };
  }, [deadzone]);
  
  return inputs;
};

// Helper functions
const isXboxController = (gamepad: Gamepad | null): boolean => {
  if (!gamepad) return false;
  
  // Check if it's an Xbox controller or using standard mapping
  return (
    gamepad.id.toLowerCase().includes('xbox') || 
    gamepad.mapping === 'standard'
  );
};

const applyDeadzone = (value: number, deadzone: number): number => {
  if (Math.abs(value) < deadzone) {
    return 0;
  }
  
  // Rescale the values to be proportional from deadzone to 1.0
  return value > 0 
    ? (value - deadzone) / (1 - deadzone)
    : (value + deadzone) / (1 - deadzone);
};

// Usage example
// const MyComponent = () => {
//   const controller = useXboxController();
//   
//   useEffect(() => {
//     if (controller.buttons.a) {
//       console.log('A button pressed!');
//     }
//     
//     if (Math.abs(controller.leftStick.x) > 0 || Math.abs(controller.leftStick.y) > 0) {
//       console.log('Moving with left stick:', controller.leftStick);
//     }
//   }, [controller]);
//   
//   return (
//     <div>
//       <p>Controller {controller.connected ? 'connected' : 'disconnected'}</p>
//     </div>
//   );
// };
// src/__tests__/WebXRTechDemo.test.tsx
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, cleanup } from '@testing-library/react';
import { WebXRTechDemo } from '../WebXRTechDemo';

// Mock the dependencies
vi.mock('@react-three/xr', () => ({
  useXR: () => ({ isPresenting: false }),
  VRButton: () => <button data-testid="vr-button">Enter VR</button>,
  Controllers: () => <div data-testid="controllers" />,
  Hands: () => <div data-testid="hands" />,
  Interactive: ({ children }) => children
}));

vi.mock('@react-three/fiber', () => ({
  Canvas: ({ children }) => <div data-testid="canvas">{children}</div>,
  useFrame: vi.fn((callback) => callback()),
  useThree: () => ({ camera: { position: { set: vi.fn() } } })
}));

vi.mock('@react-three/drei', () => ({
  PointerLockControls: () => <div data-testid="pointer-lock-controls" />
}));

describe('WebXRTechDemo', () => {
  beforeEach(() => {
    // Mock gamepad API
    global.navigator.getGamepads = vi.fn(() => []);
    
    // Mock requestAnimationFrame
    global.requestAnimationFrame = vi.fn(callback => {
      callback(0);
      return 0;
    });
  });

  afterEach(() => {
    cleanup();
    vi.resetAllMocks();
  });

  it('renders without crashing', () => {
    render(<WebXRTechDemo />);
    expect(screen.getByTestId('canvas')).toBeInTheDocument();
    expect(screen.getByTestId('vr-button')).toBeInTheDocument();
  });

  it('renders VR controls', () => {
    render(<WebXRTechDemo />);
    expect(screen.getByTestId('controllers')).toBeInTheDocument();
    expect(screen.getByTestId('hands')).toBeInTheDocument();
  });
});

// src/__tests__/NetworkVisualizationXR.test.tsx
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render } from '@testing-library/react';
import { NetworkVisualizationXR } from '../NetworkVisualizationXR';

// Mock the THREE.js related objects
vi.mock('three', () => {
  const actualThree = vi.importActual('three');
  return {
    ...actualThree,
    Points: vi.fn().mockImplementation(() => ({
      geometry: {
        attributes: {
          position: { setXYZ: vi.fn(), needsUpdate: false },
          color: { setXYZ: vi.fn(), needsUpdate: false }
        }
      }
    })),
    LineSegments: vi.fn().mockImplementation(() => ({
      geometry: {
        attributes: {
          position: { setXYZ: vi.fn(), needsUpdate: false },
          color: { setXYZ: vi.fn(), needsUpdate: false }
        }
      }
    })),
    Color: vi.fn().mockImplementation(() => ({
      setHSL: vi.fn().mockReturnThis(),
      r: 0, g: 0, b: 0
    }))
  };
});

// Mock d3 force simulation
vi.mock('d3', () => ({
  forceSimulation: vi.fn().mockReturnValue({
    force: vi.fn().mockReturnThis(),
    tick: vi.fn()
  }),
  forceLink: vi.fn().mockReturnValue({}),
  forceManyBody: vi.fn().mockReturnValue({ strength: vi.fn().mockReturnThis() }),
  forceCenter: vi.fn().mockReturnValue({}),
  forceCollide: vi.fn().mockReturnValue({ radius: vi.fn().mockReturnThis() }),
  forceZ: vi.fn().mockReturnValue({ strength: vi.fn().mockReturnThis() })
}));

// Mock React hooks and XR
vi.mock('@react-three/fiber', () => ({
  useFrame: vi.fn(callback => callback())
}));

vi.mock('@react-three/xr', () => ({
  useXR: () => ({ isPresenting: false }),
  Interactive: ({ children }) => children
}));

describe('NetworkVisualizationXR', () => {
  beforeEach(() => {
    // Mock refs
    global.navigator.getGamepads = vi.fn(() => []);
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('renders with default props', () => {
    const { container } = render(<NetworkVisualizationXR />);
    expect(container).toBeTruthy();
  });

  it('accepts custom position and scale', () => {
    const { container } = render(<NetworkVisualizationXR position={[1, 2, 3]} scale={2} />);
    expect(container).toBeTruthy();
  });

  it('calls onNodeSelected when a node is selected', () => {
    const mockOnNodeSelected = vi.fn();
    render(<NetworkVisualizationXR onNodeSelected={mockOnNodeSelected} />);
    // This would need to simulate a node selection event
    // which is challenging in a unit test context
  });
});

// src/__tests__/useXboxController.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useXboxController } from '../hooks/useXboxController';

describe('useXboxController', () => {
  beforeEach(() => {
    // Mock gamepad API
    global.navigator.getGamepads = vi.fn(() => []);
    
    // Mock window event listeners
    global.window.addEventListener = vi.fn();
    global.window.removeEventListener = vi.fn();
    
    // Mock requestAnimationFrame
    global.requestAnimationFrame = vi.fn(callback => {
      callback(0);
      return 0;
    });
    
    global.cancelAnimationFrame = vi.fn();
  });
  
  it('returns default state when no controller is connected', () => {
    const { result } = renderHook(() => useXboxController());
    
    expect(result.current.connected).toBe(false);
    expect(result.current.leftStick).toEqual({ x: 0, y: 0 });
    expect(result.current.rightStick).toEqual({ x: 0, y: 0 });
    expect(result.current.buttons.a).toBe(false);
  });
  
  it('detects connected Xbox controller', () => {
    // Mock a connected Xbox controller
    const mockXboxController = {
      id: 'Xbox Controller (Vendor: 045e Product: 02fd)',
      mapping: 'standard',
      axes: [0, 0, 0, 0],
      buttons: Array(16).fill({ pressed: false, value: 0 }),
      connected: true
    };
    
    global.navigator.getGamepads = vi.fn(() => [mockXboxController]);
    
    const { result } = renderHook(() => useXboxController());
    
    // Force a re-render to process the controller
    act(() => {
      global.requestAnimationFrame.mock.calls[0][0](0);
    });
    
    expect(result.current.connected).toBe(true);
  });
  
  it('processes controller inputs correctly', () => {
    // Mock an Xbox controller with specific inputs
    const mockXboxController = {
      id: 'Xbox Controller',
      mapping: 'standard',
      axes: [0.5, -0.7, 0.3, 0.1], // Left stick x/y, right stick x/y
      buttons: Array(16).fill({ pressed: false, value: 0 }),
      connected: true
    };
    
    // Set the A button to pressed
    mockXboxController.buttons[0] = { pressed: true, value: 1 };
    // Set right trigger partially pressed
    mockXboxController.buttons[7] = { pressed: false, value: 0.8 };
    
    global.navigator.getGamepads = vi.fn(() => [mockXboxController]);
    
    const { result } = renderHook(() => useXboxController(0.1));
    
    // Force a re-render to process the controller
    act(() => {
      global.requestAnimationFrame.mock.calls[0][0](0);
    });
    
    expect(result.current.connected).toBe(true);
    expect(result.current.leftStick.x).toBeCloseTo(0.444, 2); // Accounting for deadzone
    expect(result.current.leftStick.y).toBeCloseTo(-0.667, 2); // Accounting for deadzone
    expect(result.current.buttons.a).toBe(true);
    expect(result.current.rightTrigger).toBe(0.8);
  });
  
  it('applies deadzone correctly', () => {
    // Mock an Xbox controller with small stick movements
    const mockXboxController = {
      id: 'Xbox Controller',
      mapping: 'standard',
      axes: [0.05, 0.08, 0.2, 0.3], // Values for sticks
      buttons: Array(16).fill({ pressed: false, value: 0 }),
      connected: true
    };
    
    global.navigator.getGamepads = vi.fn(() => [mockXboxController]);
    
    const { result } = renderHook(() => useXboxController(0.1));
    
    // Force a re-render to process the controller
    act(() => {
      global.requestAnimationFrame.mock.calls[0][0](0);
    });
    
    // Values within deadzone should be zero
    expect(result.current.leftStick.x).toBe(0);
    expect(result.current.leftStick.y).toBe(0);
    
    // Values outside deadzone should be normalized
    expect(result.current.rightStick.x).toBeGreaterThan(0);
    expect(result.current.rightStick.y).toBeGreaterThan(0);
  });
});

// src/__tests__/Environment.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, fireEvent, screen } from '@testing-library/react';
import { Environment } from '../Environment';

// Mock dependencies
vi.mock('@react-three/xr', () => ({
  useXR: () => ({ isPresenting: false }),
  Interactive: ({ children, onSelect }) => (
    <div onClick={onSelect} data-testid="interactive">
      {children}
    </div>
  )
}));

vi.mock('@react-three/fiber', () => ({
  useFrame: vi.fn(callback => callback()),
  useThree: () => ({ camera: { position: { set: vi.fn() } } })
}));

vi.mock('../NetworkVisualizationXR', () => ({
  NetworkVisualizationXR: ({ position, scale, onNodeSelected }) => (
    <div data-testid="network-visualization">NetworkVisualization</div>
  )
}));

describe('Environment', () => {
  beforeEach(() => {
    global.navigator.getGamepads = vi.fn(() => []);
  });

  it('renders initial menu state', () => {
    render(<Environment />);
    // Check for portals in the menu view
    const interactiveElements = screen.getAllByTestId('interactive');
    expect(interactiveElements.length).toBeGreaterThan(0);
  });

  it('changes view when portal is clicked', () => {
    render(<Environment />);
    
    // Find the first portal and click it
    const portals = screen.getAllByTestId('interactive');
    fireEvent.click(portals[0]);
    
    // Should now show the selected view component
    expect(screen.getByTestId('network-visualization')).toBeInTheDocument();
  });

  it('returns to menu when back button is clicked', () => {
    render(<Environment />);
    
    // Navigate to a component view
    const portals = screen.getAllByTestId('interactive');
    fireEvent.click(portals[0]);
    
    // Find back button and click it
    const backButton = screen.getByText(/Back to Menu/i);
    fireEvent.click(backButton);
    
    // Should now show portals again
    const interactiveElementsAfterBack = screen.getAllByTestId('interactive');
    expect(interactiveElementsAfterBack.length).toBeGreaterThan(0);
  });
});
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render } from '@testing-library/react';
import { PortfolioEnvironment } from '../src/components/environment/PortfolioEnvironment';

// Mock React Three Fiber
vi.mock('@react-three/fiber', () => ({
  useFrame: vi.fn((callback) => {
    callback({}, 0.1); // Call with mock state and delta
    return null;
  }),
}));

// Mock Three.js
vi.mock('three', () => ({
  Vector3: vi.fn((x = 0, y = 0, z = 0) => ({ x, y, z })),
  Euler: vi.fn((x = 0, y = 0, z = 0) => ({ x, y, z })),
  Mesh: vi.fn(() => ({
    rotation: { x: 0, y: 0, z: 0 },
    position: { x: 0, y: 0, z: 0 },
  })),
  Group: vi.fn(() => ({
    rotation: { y: 0 },
    children: Array(20).fill({
      rotation: { x: 0, y: 0, z: 0 }
    }),
  })),
  PlaneGeometry: vi.fn(),
  SphereGeometry: vi.fn(),
  MeshStandardMaterial: vi.fn(),
  DirectionalLight: vi.fn(() => ({
    position: { set: vi.fn() },
    shadow: {},
  })),
  PointLight: vi.fn(() => ({
    position: { set: vi.fn() },
  })),
  AmbientLight: vi.fn(),
  OrthographicCamera: vi.fn(),
  MathUtils: {
    randFloatSpread: vi.fn((range) => range * Math.random() - range / 2),
  },
}));

describe('PortfolioEnvironment Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Mock random function to ensure consistent test results
    const randomOriginal = Math.random;
    Math.random = vi.fn().mockReturnValue(0.5);
    
    return () => {
      Math.random = randomOriginal;
    };
  });

  it('renders without crashing', () => {
    const { container } = render(<PortfolioEnvironment />);
    expect(container).toBeTruthy();
  });

  it('generates cloud points', () => {
    const THREE = require('three');
    
    render(<PortfolioEnvironment />);
    
    // Check if Vector3 was used to position clouds
    expect(THREE.Vector3).toHaveBeenCalled();
    // Check if Euler was used for cloud rotations
    expect(THREE.Euler).toHaveBeenCalled();
  });

  it('sets up refs for floor and clouds', () => {
    const useRefSpy = vi.spyOn(React, 'useRef');
    
    render(<PortfolioEnvironment />);
    
    // Check if useRef was called for floor and clouds
    expect(useRefSpy).toHaveBeenCalledTimes(2);
    
    // Cleanup
    useRefSpy.mockRestore();
  });

  it('animates clouds with useFrame', () => {
    const { useFrame } = require('@react-three/fiber');
    
    render(<PortfolioEnvironment />);
    
    // Check if useFrame was called for animation
    expect(useFrame).toHaveBeenCalled();
  });

  it('includes appropriate light setup', () => {
    const THREE = require('three');
    
    render(<PortfolioEnvironment />);
    
    // Check if lights were created
    expect(THREE.AmbientLight).toHaveBeenCalled();
    expect(THREE.DirectionalLight).toHaveBeenCalled();
    expect(THREE.PointLight).toHaveBeenCalledTimes(2);
  });

  it('creates floor grid with proper materials', () => {
    const THREE = require('three');
    
    render(<PortfolioEnvironment />);
    
    // Check if floor geometry and material were created
    expect(THREE.PlaneGeometry).toHaveBeenCalled();
    expect(THREE.MeshStandardMaterial).toHaveBeenCalled();
  });

  it('creates cloud spheres with proper materials', () => {
    const THREE = require('three');
    
    render(<PortfolioEnvironment />);
    
    // Check if sphere geometry and material were created
    expect(THREE.SphereGeometry).toHaveBeenCalled();
    expect(THREE.MeshStandardMaterial).toHaveBeenCalled();
  });

  it('rotates cloud group in animation', () => {
    // Directly test that the animation function rotates clouds
    const cloudsRef = { current: { rotation: { y: 0 }, children: [] } };
    const useRefMock = vi.spyOn(React, 'useRef');
    useRefMock.mockReturnValueOnce({ current: null }); // floor ref
    useRefMock.mockReturnValueOnce(cloudsRef); // clouds ref
    
    render(<PortfolioEnvironment />);
    
    // Animation would have been called via useFrame
    // but since we're mocking, we need to verify the setup
    expect(useRefMock).toHaveBeenCalledTimes(2);
    
    // Cleanup
    useRefMock.mockRestore();
  });
});
import React, { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

interface CloudPoint {
  position: THREE.Vector3;
  rotation: THREE.Euler;
  scale: number;
}

const PortfolioEnvironment: React.FC = () => {
  const floorRef = useRef<THREE.Mesh>(null);
  const cloudsRef = useRef<THREE.Group>(null);

  // Generate cloud points
  const cloudPoints: CloudPoint[] = Array.from({ length: 20 }, () => ({
    position: new THREE.Vector3(
      (Math.random() - 0.5) * 40,
      10 + Math.random() * 5,
      (Math.random() - 0.5) * 40
    ),
    rotation: new THREE.Euler(
      Math.random() * Math.PI,
      Math.random() * Math.PI,
      Math.random() * Math.PI
    ),
    scale: 1 + Math.random() * 2
  }));

  // Animate clouds
  useFrame((_, delta: number) => {
    if (cloudsRef.current) {
      cloudsRef.current.rotation.y += delta * 0.02;
      
      cloudsRef.current.children.forEach((cloud, i) => {
        cloud.rotation.x += delta * 0.1 * (i % 2 ? 1 : -1);
        cloud.rotation.z += delta * 0.1 * (i % 2 ? -1 : 1);
      });
    }
  });

  return (
    <group>
      {/* Floor grid */}
      <mesh 
        ref={floorRef}
        rotation={[-Math.PI / 2, 0, 0]} 
        position={[0, -0.001, 0]}
      >
        <planeGeometry args={[100, 100, 100, 100]} />
        <meshStandardMaterial 
          color="#666666"
          wireframe
          transparent
          opacity={0.3}
        />
      </mesh>

      {/* Clouds */}
      <group ref={cloudsRef}>
        {cloudPoints.map((point, i) => (
          <mesh
            key={i}
            position={point.position}
            rotation={point.rotation}
            scale={point.scale}
          >
            <sphereGeometry args={[1, 8, 8]} />
            <meshStandardMaterial
              color="#ffffff"
              transparent
              opacity={0.2}
              depthWrite={false}
            />
          </mesh>
        ))}
      </group>

      {/* Ambient lighting */}
      <ambientLight intensity={0.4} />
      
      {/* Directional light for shadows */}
      <directionalLight
        position={[10, 10, 5]}
        intensity={0.5}
        castShadow
        shadow-mapSize={[2048, 2048]}
      >
        <orthographicCamera
          attach="shadow-camera"
          args={[-10, 10, 10, -10, 0.1, 50]}
        />
      </directionalLight>

      {/* Additional point lights for ambiance */}
      <pointLight position={[-10, 5, -10]} intensity={0.3} color="#4466ff" />
      <pointLight position={[10, 5, 10]} intensity={0.3} color="#ff4466" />
    </group>
  );
};

export { PortfolioEnvironment };
// src/components/GemmaScene.tsx
import React, { useRef, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import * as THREE from 'three';

interface GemmaSceneProps {
  geometry?: THREE.BufferGeometry; // Allow a geometry to be passed in
  material?: THREE.Material;     // Allow a material to be passed in
}

const GemmaScene: React.FC<GemmaSceneProps> = ({ geometry, material }) => {
  const meshRef = useRef<THREE.Mesh>(null!);

  useFrame((state, delta) => {
    if (meshRef.current) {
      meshRef.current.rotation.x += delta;
      meshRef.current.rotation.y += delta * 0.5;
    }
  });

  // Use provided geometry and material, or defaults
  const defaultGeometry = new THREE.BoxGeometry(1, 1, 1);
  const defaultMaterial = new THREE.MeshStandardMaterial({ color: 'purple' });

  return (
    <>
      <ambientLight intensity={0.5} />
      <pointLight position={[10, 10, 10]} />
      <mesh ref={meshRef} geometry={geometry || defaultGeometry} material={material || defaultMaterial} />
      <OrbitControls />
    </>
  );
};

export default GemmaScene;import React, { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import { Interactive, useXR } from '@react-three/xr';
import * as THREE from 'three';
import { VisualizationProps } from '../../types';

interface Neuron {
  position: THREE.Vector3;
  activation: number;
  layer: number;
  index: number;
}

interface Connection {
  source: Neuron;
  target: Neuron;
  weight: number;
  signal: number;
}

const NeuralNetworkXR: React.FC<VisualizationProps> = ({ position = [0, 0, 0], scale = 1 }) => {
  const { isPresenting } = useXR();
  const neuronsRef = useRef<THREE.Points>(null);
  const connectionsRef = useRef<THREE.LineSegments>(null);

  // Generate neural network structure
  const { neurons, connections, neuronPositions, neuronColors, connectionPositions, connectionColors } = useMemo(() => {
    const layers = [4, 6, 6, 4];
    const neurons: Neuron[] = [];
    const connections: Connection[] = [];
    const layerSpacing = 2 * scale;
    const neuronSpacing = 1 * scale;

    // Create neurons
    layers.forEach((layerSize, layerIndex) => {
      const layerOffset = (layerIndex - (layers.length - 1) / 2) * layerSpacing;
      const verticalOffset = (layerSize - 1) * neuronSpacing / 2;

      for (let i = 0; i < layerSize; i++) {
        neurons.push({
          position: new THREE.Vector3(
            layerOffset,
            i * neuronSpacing - verticalOffset,
            0
          ),
          activation: 0,
          layer: layerIndex,
          index: i
        });
      }
    });

    // Create connections
    for (let i = 0; i < layers.length - 1; i++) {
      const sourceLayer = neurons.filter(n => n.layer === i);
      const targetLayer = neurons.filter(n => n.layer === i + 1);

      sourceLayer.forEach(source => {
        targetLayer.forEach(target => {
          connections.push({
            source,
            target,
            weight: Math.random() * 2 - 1,
            signal: 0
          });
        });
      });
    }

    // Create geometry attributes
    const neuronPositions = new Float32Array(neurons.length * 3);
    const neuronColors = new Float32Array(neurons.length * 3);
    const connectionPositions = new Float32Array(connections.length * 6);
    const connectionColors = new Float32Array(connections.length * 6);

    neurons.forEach((neuron, i) => {
      neuronPositions[i * 3] = neuron.position.x;
      neuronPositions[i * 3 + 1] = neuron.position.y;
      neuronPositions[i * 3 + 2] = neuron.position.z;

      const color = new THREE.Color().setHSL(
        neuron.layer / layers.length,
        0.8,
        0.5
      );
      neuronColors[i * 3] = color.r;
      neuronColors[i * 3 + 1] = color.g;
      neuronColors[i * 3 + 2] = color.b;
    });

    connections.forEach((connection, i) => {
      connectionPositions[i * 6] = connection.source.position.x;
      connectionPositions[i * 6 + 1] = connection.source.position.y;
      connectionPositions[i * 6 + 2] = connection.source.position.z;
      connectionPositions[i * 6 + 3] = connection.target.position.x;
      connectionPositions[i * 6 + 4] = connection.target.position.y;
      connectionPositions[i * 6 + 5] = connection.target.position.z;

      const color = new THREE.Color().setHSL(
        (connection.weight + 1) / 2,
        0.8,
        0.5
      );
      connectionColors[i * 6] = color.r;
      connectionColors[i * 6 + 1] = color.g;
      connectionColors[i * 6 + 2] = color.b;
      connectionColors[i * 6 + 3] = color.r;
      connectionColors[i * 6 + 4] = color.g;
      connectionColors[i * 6 + 5] = color.b;
    });

    return { neurons, connections, neuronPositions, neuronColors, connectionPositions, connectionColors };
  }, [scale]);

  // Handle neuron activation
  const activateNeuron = (neuron: Neuron): void => {
    neuron.activation = 1;
    const outgoingConnections = connections.filter(c => c.source === neuron);
    outgoingConnections.forEach(connection => {
      connection.signal = 1;
    });
  };

  // Animation loop
  useFrame((_, delta) => {
    if (!neuronsRef.current || !connectionsRef.current) return;

    // Update neuron activations
    neurons.forEach((neuron, i) => {
      if (neuron.activation > 0) {
        neuron.activation = Math.max(0, neuron.activation - delta);
        const colors = neuronsRef.current!.geometry.attributes.color;
        const color = new THREE.Color().setHSL(
          neuron.layer / neurons.length,
          0.8,
          0.5 + neuron.activation * 0.5
        );
        colors.setXYZ(i, color.r, color.g, color.b);
        colors.needsUpdate = true;
      }
    });

    // Update connection signals
    connections.forEach((connection, i) => {
      if (connection.signal > 0) {
        connection.signal = Math.max(0, connection.signal - delta);
        const colors = connectionsRef.current!.geometry.attributes.color;
        const color = new THREE.Color().setHSL(
          (connection.weight + 1) / 2,
          0.8,
          0.5 + connection.signal * 0.5
        );
        colors.setXYZ(i * 2, color.r, color.g, color.b);
        colors.setXYZ(i * 2 + 1, color.r, color.g, color.b);
        colors.needsUpdate = true;

        // Propagate signal to target neuron
        if (connection.signal < 0.1 && connection.target.activation === 0) {
          activateNeuron(connection.target);
        }
      }
    });
  });

  return (
    <group position={position}>
      {/* Connections */}
      <lineSegments ref={connectionsRef}>
        <bufferGeometry>
          <bufferAttribute
            attach="attributes-position"
            count={connectionPositions.length / 3}
            array={connectionPositions}
            itemSize={3}
          />
          <bufferAttribute
            attach="attributes-color"
            count={connectionColors.length / 3}
            array={connectionColors}
            itemSize={3}
          />
        </bufferGeometry>
        <lineBasicMaterial
          vertexColors
          transparent
          opacity={0.6}
          depthWrite={false}
        />
      </lineSegments>

      {/* Neurons */}
      <points ref={neuronsRef}>
        <bufferGeometry>
          <bufferAttribute
            attach="attributes-position"
            count={neuronPositions.length / 3}
            array={neuronPositions}
            itemSize={3}
          />
          <bufferAttribute
            attach="attributes-color"
            count={neuronColors.length / 3}
            array={neuronColors}
            itemSize={3}
          />
        </bufferGeometry>
        <pointsMaterial
          size={0.2 * scale}
          vertexColors
          sizeAttenuation
          transparent
          depthWrite={false}
        />
      </points>

      {/* Neuron interaction spheres */}
      {isPresenting && neurons.map((neuron) => (
        <Interactive
          key={`${neuron.layer}-${neuron.index}`}
          onSelect={() => activateNeuron(neuron)}
        >
          <mesh position={neuron.position}>
            <sphereGeometry args={[0.1 * scale, 8, 8]} />
            <meshBasicMaterial
              transparent
              opacity={0}
            />
          </mesh>
        </Interactive>
      ))}
    </group>
  );
};

export { NeuralNetworkXR };
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render } from '@testing-library/react';
import { NeuralNetworkXR } from '../src/components/visualizations/NeuralNetworkXR';

// Mock React Three Fiber
vi.mock('@react-three/fiber', () => ({
  useFrame: vi.fn((callback) => {
    callback({}, 0.1); // Call with mock state and delta
    return null;
  }),
}));

// Mock React Three XR
vi.mock('@react-three/xr', () => ({
  useXR: vi.fn(() => ({
    isPresenting: false,
  })),
  Interactive: ({ children }) => children,
}));

// Mock Three.js with necessary components for NeuralNetworkXR
vi.mock('three', () => ({
  Vector3: vi.fn((x = 0, y = 0, z = 0) => ({ x, y, z })),
  Euler: vi.fn((x = 0, y = 0, z = 0) => ({ x, y, z })),
  Group: vi.fn(() => ({
    position: { x: 0, y: 0, z: 0 },
  })),
  Points: vi.fn(() => ({
    geometry: {
      attributes: {
        position: {
          count: 20,
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
        color: {
          count: 20,
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
      },
    },
  })),
  LineSegments: vi.fn(() => ({
    geometry: {
      attributes: {
        position: {
          count: 60,
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
        color: {
          count: 60,
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
      },
    },
  })),
  Mesh: vi.fn(() => ({
    position: { x: 0, y: 0, z: 0 },
  })),
  BoxGeometry: vi.fn(),
  SphereGeometry: vi.fn(),
  BufferGeometry: vi.fn(),
  Color: vi.fn(() => ({
    setHSL: vi.fn().mockReturnThis(),
    r: 0, g: 0, b: 0,
  })),
  Float32BufferAttribute: vi.fn(),
  LineBasicMaterial: vi.fn(),
  PointsMaterial: vi.fn(),
  MeshBasicMaterial: vi.fn(),
}));

describe('NeuralNetworkXR Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders without crashing', () => {
    const { container } = render(<NeuralNetworkXR />);
    expect(container).toBeTruthy();
  });

  it('accepts position and scale props', () => {
    const position = [1, 2, 3];
    const scale = 2;
    
    const { container } = render(
      <NeuralNetworkXR position={position} scale={scale} />
    );
    
    expect(container).toBeTruthy();
  });

  it('creates neural network structure with neurons and connections', () => {
    const useMemoSpy = vi.spyOn(React, 'useMemo');
    
    render(<NeuralNetworkXR />);
    
    // Check if useMemo was called to set up the network structure
    expect(useMemoSpy).toHaveBeenCalled();
    
    // Cleanup
    useMemoSpy.mockRestore();
  });

  it('sets up refs for neurons and connections', () => {
    const useRefSpy = vi.spyOn(React, 'useRef');
    
    render(<NeuralNetworkXR />);
    
    // Check if useRef was called for neurons and connections
    expect(useRefSpy).toHaveBeenCalledTimes(2);
    
    // Cleanup
    useRefSpy.mockRestore();
  });

  it('updates neuron activations in animation frame', () => {
    const { useFrame } = require('@react-three/fiber');
    
    render(<NeuralNetworkXR />);
    
    // Check if useFrame was called to handle animations
    expect(useFrame).toHaveBeenCalled();
  });

  it('adapts to XR mode', () => {
    const { useXR } = require('@react-three/xr');
    
    // First test with isPresenting = false
    render(<NeuralNetworkXR />);
    expect(useXR).toHaveReturnedWith({ isPresenting: false });
    
    // Mock XR presenting mode
    useXR.mockReturnValue({ isPresenting: true });
    
    // Render again
    render(<NeuralNetworkXR />);
    expect(useXR).toHaveReturnedWith({ isPresenting: true });
  });

  it('implements neuron activation function', () => {
    // Get access to the activateNeuron function via mocking
    let capturedActivateNeuron;
    const originalUseFrame = require('@react-three/fiber').useFrame;
    
    require('@react-three/fiber').useFrame.mockImplementation((callback) => {
      // Extract the activateNeuron function from the component
      capturedActivateNeuron = callback.toString().includes('activateNeuron');
      return originalUseFrame(callback);
    });
    
    render(<NeuralNetworkXR />);
    
    // Check if the function was defined
    expect(capturedActivateNeuron).toBeTruthy();
    
    // Reset the mock
    require('@react-three/fiber').useFrame = originalUseFrame;
  });

  it('creates appropriate layer structure', () => {
    const THREE = require('three');
    
    render(<NeuralNetworkXR />);
    
    // Check if Vector3 was used to position neurons in layers
    expect(THREE.Vector3).toHaveBeenCalled();
  });
});
import React, { useRef, useMemo, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { useXR, Interactive } from '@react-three/xr';
import * as THREE from 'three';
import * as d3 from 'd3';
import { VisualizationProps } from '../../types';

interface Node extends d3.SimulationNodeDatum {
  id: string;
  group: number;
  value: number;
  x?: number;
  y?: number;
  z?: number;
}

interface Link extends d3.SimulationLinkDatum<Node> {
  source: Node;
  target: Node;
  value: number;
}

interface ControllerState {
  isConnected: boolean;
  buttonPressed: boolean;
}

export const NetworkVisualizationXR: React.FC<VisualizationProps> = ({ 
  position = [0, 0, 0], 
  scale = 1,
  onNodeSelected = (nodeId: string) => {} 
}) => {
  const { isPresenting } = useXR();
  const nodesRef = useRef<THREE.Points>(null);
  const edgesRef = useRef<THREE.LineSegments>(null);
  const [selectedNode, setSelectedNode] = useState<string | null>(null);
  const [controllerState, setControllerState] = useState<ControllerState>({
    isConnected: false,
    buttonPressed: false
  });
  
  // Handle node selection with feedback to parent
  const handleNodeSelect = (nodeId: string): void => {
    const newSelection = nodeId === selectedNode ? null : nodeId;
    setSelectedNode(newSelection);
    onNodeSelected(newSelection || '');
  };

  // Generate network data
  const { nodes, links, simulation } = useMemo(() => {
    const nodeCount = isPresenting ? 30 : 50;
    const nodes: Node[] = Array.from({ length: nodeCount }, (_, i) => ({
      id: `node-${i}`,
      group: Math.floor(Math.random() * 5),
      value: Math.random(),
    }));

    const links: Link[] = [];
    nodes.forEach((node, i) => {
      const numLinks = Math.floor(Math.random() * 3) + 1;
      for (let j = 0; j < numLinks; j++) {
        const targetIndex = Math.floor(Math.random() * nodes.length);
        if (targetIndex !== i) {
          links.push({
            source: node,
            target: nodes[targetIndex],
            value: Math.random(),
          });
        }
      }
    });

    // Create force simulation
    const simulation = d3.forceSimulation<Node, Link>(nodes)
      .force('link', d3.forceLink<Node, Link>(links).id(d => d.id))
      .force('charge', d3.forceManyBody().strength(-30))
      .force('center', d3.forceCenter(0, 0))
      .force('collision', d3.forceCollide().radius(0.5));
      
    // Add third dimension to simulation
    simulation.force('z', d3.forceZ(0).strength(0.01));
    
    return { nodes, links, simulation };
  }, [isPresenting]);

  // Xbox controller support for node manipulation
  useEffect(() => {
    const handleGamepadConnected = (event) => {
      setControllerState(prev => ({ ...prev, isConnected: true }));
      console.log("Xbox controller connected:", event.gamepad);
    };
    
    const handleGamepadDisconnected = () => {
      setControllerState(prev => ({ ...prev, isConnected: false }));
    };
    
    window.addEventListener('gamepadconnected', handleGamepadConnected);
    window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);
    
    return () => {
      window.removeEventListener('gamepadconnected', handleGamepadConnected);
      window.removeEventListener('gamepaddisconnected', handleGamepadDisconnected);
    };
  }, []);

  // Update positions in animation loop and handle controller input
  useFrame(() => {
    if (!nodesRef.current || !edgesRef.current) return;

    // Process Xbox controller input
    const gamepads = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
    const xboxController = gamepads.find(gamepad => 
      gamepad && (gamepad.id.includes('Xbox') || gamepad.mapping === 'standard')
    );
    
    if (xboxController) {
      // Use right stick to manipulate the network (rotate/scale)
      const rightStickX = xboxController.axes[2]; // Right stick X
      const rightStickY = xboxController.axes[3]; // Right stick Y
      
      // Apply rotation to simulation based on right stick
      if (Math.abs(rightStickX) > 0.1) {
        nodes.forEach(node => {
          if (node.x !== undefined && node.z !== undefined) {
            // Rotate around Y axis
            const x = node.x;
            const z = node.z;
            node.x = x * Math.cos(rightStickX * 0.05) - z * Math.sin(rightStickX * 0.05);
            node.z = x * Math.sin(rightStickX * 0.05) + z * Math.cos(rightStickX * 0.05);
          }
        });
      }
      
      // Scale simulation based on triggers
      const rightTrigger = xboxController.buttons[7]?.value || 0; // RT
      const leftTrigger = xboxController.buttons[6]?.value || 0; // LT
      
      if (rightTrigger > 0.1 || leftTrigger > 0.1) {
        const scaleFactor = 1 + (rightTrigger - leftTrigger) * 0.02;
        nodes.forEach(node => {
          if (node.x !== undefined && node.y !== undefined && node.z !== undefined) {
            node.x *= scaleFactor;
            node.y *= scaleFactor;
            node.z *= scaleFactor;
          }
        });
      }
      
      // A button to select nearest node
      const aButtonPressed = xboxController.buttons[0]?.pressed;
      if (aButtonPressed && !controllerState.buttonPressed) {
        // Find nearest node to controller
        // In a real implementation, you would use the controller position
        // For this example, we'll just select a random node
        const randomNodeIndex = Math.floor(Math.random() * nodes.length);
        handleNodeSelect(nodes[randomNodeIndex].id);
      }
      
      setControllerState(prev => ({ 
        ...prev, 
        buttonPressed: aButtonPressed 
      }));
    }

    simulation.tick();

    // Update node positions
    const nodePositions = nodesRef.current.geometry.attributes.position;
    const nodeColors = nodesRef.current.geometry.attributes.color;

    nodes.forEach((node, i) => {
      if (node.x !== undefined && node.y !== undefined) {
        nodePositions.setXYZ(
          i,
          node.x * scale,
          node.y * scale,
          (node.z || 0) * scale
        );

        const color = new THREE.Color().setHSL(
          node.group / 5,
          0.8,
          selectedNode === node.id ? 0.8 : 0.5
        );
        nodeColors.setXYZ(i, color.r, color.g, color.b);
      }
    });

    nodePositions.needsUpdate = true;
    nodeColors.needsUpdate = true;

    // Update edge positions
    const edgePositions = edgesRef.current.geometry.attributes.position;
    const edgeColors = edgesRef.current.geometry.attributes.color;

    links.forEach((link, i) => {
      const sourceNode = link.source as Node;
      const targetNode = link.target as Node;

      if (sourceNode.x !== undefined && sourceNode.y !== undefined &&
          targetNode.x !== undefined && targetNode.y !== undefined) {
        edgePositions.setXYZ(i * 2,
          sourceNode.x * scale,
          sourceNode.y * scale,
          (sourceNode.z || 0) * scale
        );
        edgePositions.setXYZ(i * 2 + 1,
          targetNode.x * scale,
          targetNode.y * scale,
          (targetNode.z || 0) * scale
        );

        const color = new THREE.Color().setHSL(
          (sourceNode.group + targetNode.group) / 10,
          0.6,
          selectedNode === sourceNode.id || selectedNode === targetNode.id ? 0.6 : 0.3
        );
        edgeColors.setXYZ(i * 2, color.r, color.g, color.b);
        edgeColors.setXYZ(i * 2 + 1, color.r, color.g, color.b);
      }
    });

    edgePositions.needsUpdate = true;
    edgeColors.needsUpdate = true;
  });

  return (
    <group position={position}>
      {/* Edges */}
      <lineSegments ref={edgesRef}>
        <bufferGeometry>
          <bufferAttribute
            attach="attributes-position"
            count={links.length * 2}
            array={new Float32Array(links.length * 6)}
            itemSize={3}
          />
          <bufferAttribute
            attach="attributes-color"
            count={links.length * 2}
            array={new Float32Array(links.length * 6)}
            itemSize={3}
          />
        </bufferGeometry>
        <lineBasicMaterial
          vertexColors
          transparent
          opacity={0.6}
          depthWrite={false}
        />
      </lineSegments>

      {/* Nodes */}
      <points ref={nodesRef}>
        <bufferGeometry>
          <bufferAttribute
            attach="attributes-position"
            count={nodes.length}
            array={new Float32Array(nodes.length * 3)}
            itemSize={3}
          />
          <bufferAttribute
            attach="attributes-color"
            count={nodes.length}
            array={new Float32Array(nodes.length * 3)}
            itemSize={3}
          />
        </bufferGeometry>
        <pointsMaterial
          size={0.2 * scale}
          vertexColors
          sizeAttenuation
          transparent
          depthWrite={false}
        />
      </points>

      {/* Node interaction spheres */}
      {isPresenting && nodes.map((node, i) => (
        <Interactive
          key={node.id}
          onSelect={() => handleNodeSelect(node.id)}
        >
          <mesh
            position={[
              (node.x || 0) * scale,
              (node.y || 0) * scale,
              (node.z || 0) * scale
            ]}
          >
            <sphereGeometry args={[0.1 * scale, 8, 8]} />
            <meshBasicMaterial
              transparent
              opacity={0}
            />
          </mesh>
        </Interactive>
      ))}

      {/* Selected node info */}
      {selectedNode && (
        <mesh
          position={[
            ((nodes.find(n => n.id === selectedNode)?.x || 0) + 0.3) * scale,
            ((nodes.find(n => n.id === selectedNode)?.y || 0) + 0.3) * scale,
            ((nodes.find(n => n.id === selectedNode)?.z || 0)) * scale
          ]}
        >
          <planeGeometry args={[0.6, 0.2]} />
          <meshBasicMaterial
            color="#000000"
            transparent
            opacity={0.8}
            side={THREE.DoubleSide}
          />
          {/* Add text label here */}
          <mesh position={[0, 0, 0.01]}>
            <textGeometry args={[selectedNode, { size: 0.05, height: 0.01 }]} />
            <meshBasicMaterial color="white" />
          </mesh>
        </mesh>
      )}
      
      {/* Controller status indicator (helpful for debugging) */}
      {controllerState.isConnected && (
        <mesh position={[-1.5 * scale, -1 * scale, 0]}>
          <planeGeometry args={[0.8, 0.2]} />
          <meshBasicMaterial color="green" />
          <mesh position={[0, 0, 0.01]}>
            <textGeometry args={["Controller Connected", { size: 0.04, height: 0.01 }]} />
            <meshBasicMaterial color="white" />
          </mesh>
        </mesh>
      )}
    </group>
  );
};
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render } from '@testing-library/react';
import { ParticleSystemXR } from '../src/components/visualizations/ParticleSystemXR';

// Mock React Three Fiber
vi.mock('@react-three/fiber', () => ({
  useFrame: vi.fn((callback) => {
    callback({}, 0.1); // Call with mock state and delta
    return null;
  }),
}));

// Mock React Three XR
vi.mock('@react-three/xr', () => ({
  useXR: vi.fn(() => ({
    isPresenting: false,
  })),
}));

// Mock Three.js with necessary components for ParticleSystemXR
vi.mock('three', () => ({
  Vector3: vi.fn((x = 0, y = 0, z = 0) => ({ 
    x, y, z,
    add: vi.fn(),
    length: vi.fn(() => 0.5),
  })),
  Points: vi.fn(() => ({
    geometry: {
      attributes: {
        position: {
          count: 1000,
          getX: vi.fn(() => 0),
          getY: vi.fn(() => 0),
          getZ: vi.fn(() => 0),
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
        color: {
          count: 1000,
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
      },
    },
  })),
  BufferGeometry: vi.fn(),
  Color: vi.fn(() => ({
    setHSL: vi.fn().mockReturnThis(),
    r: 0, g: 0, b: 0,
  })),
  Float32BufferAttribute: vi.fn(),
  PointsMaterial: vi.fn(),
  AdditiveBlending: 'AdditiveBlending',
  Shader: class {
    vertexShader: string = '';
    fragmentShader: string = '';
  },
}));

describe('ParticleSystemXR Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders without crashing', () => {
    const { container } = render(<ParticleSystemXR />);
    expect(container).toBeTruthy();
  });

  it('accepts position and scale props', () => {
    const position = [1, 2, 3];
    const scale = 2;
    
    const { container } = render(
      <ParticleSystemXR position={position} scale={scale} />
    );
    
    expect(container).toBeTruthy();
  });

  it('generates particles using useMemo', () => {
    const useMemoSpy = vi.spyOn(React, 'useMemo');
    
    render(<ParticleSystemXR />);
    
    // Check if useMemo was called to generate particles
    expect(useMemoSpy).toHaveBeenCalled();
    
    // Cleanup
    useMemoSpy.mockRestore();
  });

  it('sets up ref for points', () => {
    const useRefSpy = vi.spyOn(React, 'useRef');
    
    render(<ParticleSystemXR />);
    
    // Check if useRef was called for points
    expect(useRefSpy).toHaveBeenCalled();
    
    // Cleanup
    useRefSpy.mockRestore();
  });

  it('updates particle positions in animation frame', () => {
    const { useFrame } = require('@react-three/fiber');
    
    render(<ParticleSystemXR />);
    
    // Check if useFrame was called to handle animations
    expect(useFrame).toHaveBeenCalled();
  });

  it('adapts particle count based on XR mode', () => {
    const { useXR } = require('@react-three/xr');
    
    // First test with isPresenting = false (higher particle count)
    render(<ParticleSystemXR />);
    expect(useXR).toHaveReturnedWith({ isPresenting: false });
    
    // Mock XR presenting mode (should use lower particle count)
    useXR.mockReturnValue({ isPresenting: true });
    
    // Render again
    render(<ParticleSystemXR />);
    expect(useXR).toHaveReturnedWith({ isPresenting: true });
  });

  it('creates particles with random properties', () => {
    const THREE = require('three');
    const Math_random = Math.random;
    
    // Mock Math.random to return predictable values
    Math.random = vi.fn(() => 0.5);
    
    render(<ParticleSystemXR />);
    
    // Check if Vector3 was used to position particles
    expect(THREE.Vector3).toHaveBeenCalled();
    // Check if Color was used to set particle colors
    expect(THREE.Color).toHaveBeenCalled();
    
    // Restore original Math.random
    Math.random = Math_random;
  });

  it('handles particle lifecycle with animation', () => {
    render(<ParticleSystemXR />);
    
    // This is mostly testing that animation functions don't crash
    // A more complex test would mock the animation frame and check for specific updates
    expect(true).toBeTruthy();
  });
});
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render } from '@testing-library/react';
import { NetworkVisualizationXR } from '../src/components/visualizations/NetworkVisualizationXR';

// Mock React Three Fiber
vi.mock('@react-three/fiber', () => ({
  useFrame: vi.fn((callback) => {
    callback({}, 0.1); // Call with mock state and delta
    return null;
  }),
}));

// Mock React Three XR
vi.mock('@react-three/xr', () => ({
  useXR: vi.fn(() => ({
    isPresenting: false,
  })),
  Interactive: ({ children }) => children,
}));

// Mock d3
vi.mock('d3', () => ({
  forceSimulation: vi.fn(() => ({
    force: vi.fn().mockReturnThis(),
    tick: vi.fn(),
  })),
  forceLink: vi.fn(() => ({
    id: vi.fn().mockReturnThis(),
  })),
  forceManyBody: vi.fn(() => ({
    strength: vi.fn().mockReturnThis(),
  })),
  forceCenter: vi.fn(),
  forceCollide: vi.fn(() => ({
    radius: vi.fn().mockReturnThis(),
  })),
}));

// Mock Three.js
vi.mock('three', () => ({
  Group: vi.fn(() => ({
    rotation: { y: 0 },
    add: vi.fn(),
  })),
  Mesh: vi.fn(() => ({
    position: { x: 0, y: 0, z: 0 },
  })),
  Points: vi.fn(() => ({
    geometry: {
      attributes: {
        position: {
          count: 30,
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
        color: {
          count: 30,
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
      },
    },
  })),
  LineSegments: vi.fn(() => ({
    geometry: {
      attributes: {
        position: {
          count: 60,
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
        color: {
          count: 60,
          setXYZ: vi.fn(),
          needsUpdate: false,
        },
      },
    },
  })),
  BoxGeometry: vi.fn(),
  SphereGeometry: vi.fn(),
  BufferGeometry: vi.fn(),
  Color: vi.fn(() => ({
    setHSL: vi.fn().mockReturnThis(),
    r: 0, g: 0, b: 0,
  })),
  Float32BufferAttribute: vi.fn(),
  LineBasicMaterial: vi.fn(),
  PointsMaterial: vi.fn(),
  MeshBasicMaterial: vi.fn(),
  DoubleSide: 'DoubleSide',
}));

describe('NetworkVisualizationXR Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders without crashing', () => {
    const { container } = render(<NetworkVisualizationXR />);
    expect(container).toBeTruthy();
  });

  it('accepts position and scale props', () => {
    const position = [1, 2, 3];
    const scale = 2;
    
    const { container } = render(
      <NetworkVisualizationXR position={position} scale={scale} />
    );
    
    expect(container).toBeTruthy();
  });

  it('initializes nodes and links with d3', () => {
    const d3 = require('d3');
    
    render(<NetworkVisualizationXR />);
    
    // Check if d3 functions were called to set up the force simulation
    expect(d3.forceSimulation).toHaveBeenCalled();
    expect(d3.forceLink).toHaveBeenCalled();
    expect(d3.forceManyBody).toHaveBeenCalled();
    expect(d3.forceCenter).toHaveBeenCalled();
    expect(d3.forceCollide).toHaveBeenCalled();
  });

  it('updates node and edge positions in animation frame', () => {
    const { useFrame } = require('@react-three/fiber');
    
    render(<NetworkVisualizationXR />);
    
    // Check if useFrame was called to animate
    expect(useFrame).toHaveBeenCalled();
  });

  it('handles node selection state', () => {
    const useStateSpy = vi.spyOn(React, 'useState');
    
    render(<NetworkVisualizationXR />);
    
    // Check if useState was called for selectedNode state
    expect(useStateSpy).toHaveBeenCalledWith(null);
    
    // Cleanup
    useStateSpy.mockRestore();
  });

  it('adapts to XR mode', () => {
    const { useXR } = require('@react-three/xr');
    
    // First test with isPresenting = false
    render(<NetworkVisualizationXR />);
    expect(useXR).toHaveReturnedWith({ isPresenting: false });
    
    // Mock XR presenting mode
    useXR.mockReturnValue({ isPresenting: true });
    
    // Render again
    render(<NetworkVisualizationXR />);
    expect(useXR).toHaveReturnedWith({ isPresenting: true });
  });

  it('uses different node counts based on XR mode', () => {
    const useMemoSpy = vi.spyOn(React, 'useMemo');
    const { useXR } = require('@react-three/xr');
    
    // Test with isPresenting = false (higher node count)
    useXR.mockReturnValue({ isPresenting: false });
    render(<NetworkVisualizationXR />);
    
    expect(useMemoSpy).toHaveBeenCalled();
    
    // Mock XR presenting mode (should use lower node count)
    useXR.mockReturnValue({ isPresenting: true });
    render(<NetworkVisualizationXR />);
    
    // Cleanup
    useMemoSpy.mockRestore();
  });
});
import React, { useRef, useMemo, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { useXR, useController, Interactive } from '@react-three/xr';
import { Text } from '@react-three/drei';
import * as THREE from 'three';
import { VisualizationProps, TerrainType } from '../../types';

export const TerrainMappingXR: React.FC<VisualizationProps> = ({ position = [0, 0, 0], scale = 1 }) => {
  const { isPresenting } = useXR();
  const terrainRef = useRef<THREE.Mesh>(null);
  const scanBarRef = useRef<THREE.Mesh>(null);
  const dataPointsRef = useRef<THREE.Points>(null);
  
  const [scanProgress, setScanProgress] = useState<number>(0);
  const [terrainType, setTerrainType] = useState<TerrainType>('mountains');
  const [interactMode, setInteractMode] = useState<boolean>(false);
  
  // XR controller for interaction
  const rightController = useController('right');
  
  // Adjust resolution based on VR mode for performance
  const resolution = isPresenting ? 32 : 64;
  const range = 5 * scale;
  const scanSpeed = 0.5;
  const heightScale = 1.5 * scale;
  
  // Generate height data based on terrain type
  const { heightData, positions, colors } = useMemo(() => {
    const res = resolution;
    const heightData = new Float32Array(res * res);
    
    // Generate different noise patterns based on the terrain type
    let noiseHeight = 1.0;
    let noiseBaseline = 0;
    
    switch (terrainType) {
      case 'mountains':
        noiseHeight = 1.0;
        noiseBaseline = 0;
        break;
      case 'canyon':
        noiseHeight = 1.2;
        noiseBaseline = -0.5;
        break;
      case 'coastal':
        noiseHeight = 0.6;
        noiseBaseline = -0.3;
        break;
      case 'urban':
        noiseHeight = 0.5;
        noiseBaseline = 0;
        break;
      default:
        // Default to mountains
        noiseHeight = 1.0;
        noiseBaseline = 0;
    }
    
    // Simple noise function for height generation
    const noise = (nx: number, ny: number): number => {
      // Simple implementation of Perlin-like noise
      const sin0 = Math.sin(nx * 1.0) * 0.5 + 0.5;
      const sin1 = Math.sin(ny * 1.0) * 0.5 + 0.5;
      const sin2 = Math.sin((nx + ny) * 2.0) * 0.5 + 0.5;
      const sin3 = Math.sin(Math.sqrt(nx * nx + ny * ny) * 5.0) * 0.5 + 0.5;
      
      let n = sin0 * 0.25 + sin1 * 0.25 + sin2 * 0.25 + sin3 * 0.25;
      
      // Add some variations based on terrain type
      if (terrainType === 'mountains') {
        // Add sharper peaks
        n = Math.pow(n, 0.8);
      } else if (terrainType === 'canyon') {
        // Create deeper valleys
        n = n < 0.4 ? n * 0.5 : n;
      } else if (terrainType === 'coastal') {
        // Create flatter areas at the bottom
        n = n < 0.3 ? 0.3 : n;
      } else if (terrainType === 'urban') {
        // Create plateaus and sudden height changes
        n = Math.floor(n * 5) / 5;
      }
      
      return n;
    };
    
    // Generate the height data
    for (let i = 0; i < res; i++) {
      for (let j = 0; j < res; j++) {
        const nx = i / res - 0.5;
        const ny = j / res - 0.5;
        
        const n1 = noise(nx * 5, ny * 5);
        const n2 = noise(nx * 10, ny * 10) * 0.5;
        const n3 = noise(nx * 20, ny * 20) * 0.25;
        
        let height = (n1 + n2 + n3) * noiseHeight + noiseBaseline;
        
        // Ensure some flat areas for urban environments
        if (terrainType === 'urban' && Math.random() > 0.7) {
          height = Math.floor(height * 3) / 3;
        }
        
        heightData[i * res + j] = height;
      }
    }
    
    // Create data points for radar scan visualization
    const pointCount = res * 4; // Fewer points than full resolution for visual clarity
    const positions = new Float32Array(pointCount * 3);
    const colors = new Float32Array(pointCount * 3);
    
    for (let i = 0; i < pointCount; i++) {
      const x = (Math.random() - 0.5) * range;
      const z = (Math.random() - 0.5) * range;
      
      // Calculate height at this position by sampling the height data
      const gridX = Math.floor((x / range + 0.5) * (res - 1));
      const gridZ = Math.floor((z / range + 0.5) * (res - 1));
      const idx = Math.min(res - 1, Math.max(0, gridX)) * res + Math.min(res - 1, Math.max(0, gridZ));
      const y = heightData[idx] * heightScale;
      
      positions[i * 3] = x;
      positions[i * 3 + 1] = y + 0.05; // Slightly above terrain
      positions[i * 3 + 2] = z;
      
      // Color based on height
      const heightColor = Math.max(0.2, Math.min((y + 1) / 2, 1));
      const hue = terrainType === 'mountains' ? 0.66 : 
                 terrainType === 'canyon' ? 0.05 :
                 terrainType === 'coastal' ? 0.55 : 
                 0.33; // urban = green
                 
      const color = new THREE.Color().setHSL(hue, 0.8, heightColor);
      colors[i * 3] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;
    }
    
    return { heightData, positions, colors };
  }, [resolution, range, terrainType, heightScale]);

  // Update animation with proper TypeScript types
  useFrame(({ clock }): void => {
    const time = clock.getElapsedTime();
    const scanPos = ((time * scanSpeed) % 2) - 1;
    setScanProgress((scanPos + 1) / 2);
    
    if (scanBarRef.current) {
      scanBarRef.current.position.z = scanPos * (range / 2);
    }
    
    if (dataPointsRef.current) {
      const positions = dataPointsRef.current.geometry.attributes.position;
      const alphas: number[] = [];
      
      for (let i = 0; i < positions.count; i++) {
        const z = positions.getZ(i);
        const normalized = (z / (range/2) + 1) / 2;
        const alpha = normalized <= scanProgress ? 1 : 0;
        alphas.push(alpha);
      }
      
      dataPointsRef.current.geometry.setAttribute(
        'alpha',
        new THREE.Float32BufferAttribute(alphas, 1)
      );
    }
    
    if (terrainRef.current?.material instanceof THREE.MeshStandardMaterial) {
      const material = terrainRef.current.material;
      if (material.displacementMap) {
        material.displacementScale = heightScale * (0.8 + Math.sin(time * 0.2) * 0.1);
      }
    }
    
    // Handle XR controller interaction
    if (isPresenting && rightController && interactMode) {
      const controllerPos = rightController.grip.position;
      const x = ((controllerPos.x - position[0]) / range + 0.5) * resolution;
      const z = ((controllerPos.z - position[2]) / range + 0.5) * resolution;
      
      if (x >= 0 && x < resolution && z >= 0 && z < resolution) {
        const idx = Math.floor(x) * resolution + Math.floor(z);
        if (heightData[idx] !== undefined) {
          const targetHeight = (controllerPos.y - position[1]) / heightScale;
          heightData[idx] = THREE.MathUtils.lerp(heightData[idx], targetHeight, 0.1);
          updateTerrainGeometry();
        }
      }
    }
  });
  
  // Update terrain geometry with proper type checking
  const updateTerrainGeometry = (): void => {
    if (!terrainRef.current) return;
    
    const geometry = terrainRef.current.geometry;
    if (!(geometry instanceof THREE.BufferGeometry)) return;
    
    const positions = geometry.attributes.position.array;
    
    for (let i = 0; i < resolution + 1; i++) {
      for (let j = 0; j < resolution + 1; j++) {
        const sampleI = Math.min(resolution - 1, i);
        const sampleJ = Math.min(resolution - 1, j);
        const height = heightData[sampleI * resolution + sampleJ];
        
        const index = (i * (resolution + 1) + j) * 3 + 1;
        positions[index] = height * heightScale;
      }
    }
    
    geometry.attributes.position.needsUpdate = true;
    geometry.computeVertexNormals();
  };
  
  // Terrain type toggle with type safety
  const handleToggleTerrain = (): void => {
    const terrainTypes: TerrainType[] = ['mountains', 'canyon', 'coastal', 'urban'];
    const currentIndex = terrainTypes.indexOf(terrainType);
    const nextIndex = (currentIndex + 1) % terrainTypes.length;
    setTerrainType(terrainTypes[nextIndex]);
  };
  
  // Interaction mode toggle
  const handleToggleInteract = (): void => {
    setInteractMode(!interactMode);
  };
  
  // Initialize terrain geometry
  useEffect(() => {
    updateTerrainGeometry();
  }, [heightData, heightScale, resolution]);
  
  return (
    <group position={position}>
      {/* Base terrain */}
      <mesh
        ref={terrainRef}
        rotation={[-Math.PI/2, 0, 0]}
      >
        <planeGeometry args={[range, range, resolution, resolution]} />
        <meshStandardMaterial
          color={terrainType === 'mountains' ? "#8791B8" : 
                terrainType === 'canyon' ? "#B85D3C" : 
                terrainType === 'coastal' ? "#6096B4" : 
                "#687D69"} // urban
          flatShading={true}
          wireframe={true}
          side={THREE.DoubleSide}
        />
      </mesh>
      
      {/* Scanning bar visualization */}
      <mesh 
        ref={scanBarRef}
        position={[0, 0.5, 0]}
      >
        <boxGeometry args={[range, 0.1, 0.05]} />
        <meshStandardMaterial
          color="#00FFAA"
          transparent
          opacity={0.8}
          emissive="#00FFAA"
          emissiveIntensity={1}
        />
      </mesh>
      
      {/* Radar data points */}
      <points ref={dataPointsRef}>
        <bufferGeometry>
          <bufferAttribute
            attach="attributes-position"
            count={positions.length / 3}
            array={positions}
            itemSize={3}
          />
          <bufferAttribute
            attach="attributes-color"
            count={colors.length / 3}
            array={colors}
            itemSize={3}
          />
          <bufferAttribute
            attach="attributes-alpha"
            count={positions.length / 3}
            array={new Float32Array(positions.length / 3).fill(0)}
            itemSize={1}
          />
        </bufferGeometry>
        <pointsMaterial
          size={0.15 * scale}
          sizeAttenuation
          vertexColors
          transparent
          opacity={0.9}
          blending={THREE.AdditiveBlending}
          depthWrite={false}
          onBeforeCompile={(shader) => {
            // Add declarations at the top of vertex shader
            shader.vertexShader = shader.vertexShader.replace(
              'varying vec3 vViewPosition;',
              'varying vec3 vViewPosition;\nvarying float vAlpha;\nattribute float alpha;'
            );

            // Update begin_vertex section
            shader.vertexShader = shader.vertexShader.replace(
              '#include <begin_vertex>',
              '#include <begin_vertex>\nvAlpha = alpha;'
            );
            
            // Add varying declaration to fragment shader
            shader.fragmentShader = shader.fragmentShader.replace(
              'varying vec3 vViewPosition;',
              'varying vec3 vViewPosition;\nvarying float vAlpha;'
            );

            // Update fragment color calculation
            shader.fragmentShader = shader.fragmentShader.replace(
              'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
              'gl_FragColor = vec4( outgoingLight, diffuseColor.a * vAlpha );'
            );
          }}
        />
      </points>
      
      {/* XR UI controls */}
      {isPresenting && (
        <group position={[0, 1.2, 0]}>
          <Interactive onSelect={handleToggleTerrain}>
            <mesh position={[-0.5, 0, 0]}>
              <boxGeometry args={[0.2, 0.1, 0.05]} />
              <meshStandardMaterial color="#4488ff" />
            </mesh>
            <Text
              position={[-0.5, 0, 0.1]}
              fontSize={0.05}
              color="white"
              anchorX="center"
              anchorY="middle"
            >
              Terrain
            </Text>
          </Interactive>
          
          <Interactive onSelect={handleToggleInteract}>
            <mesh position={[0.5, 0, 0]}>
              <boxGeometry args={[0.2, 0.1, 0.05]} />
              <meshStandardMaterial color={interactMode ? "#ff4488" : "#44ff88"} />
            </mesh>
            <Text
              position={[0.5, 0, 0.1]}
              fontSize={0.05}
              color="white"
              anchorX="center"
              anchorY="middle"
            >
              Edit
            </Text>
          </Interactive>
        </group>
      )}
      
      {/* Add labels */}
      <mesh position={[range/2 + 0.2, 0.2, 0]} rotation={[0, -Math.PI/2, 0]}>
        <planeGeometry args={[0.5, 0.2]} />
        <meshBasicMaterial color="#000000" opacity={0.7} transparent />
      </mesh>
      
      <Text
        position={[range/2 + 0.25, 0.2, 0]}
        rotation={[0, -Math.PI/2, 0]}
        fontSize={0.05}
        color="white"
        anchorX="center"
        anchorY="middle"
      >
        {terrainType.charAt(0).toUpperCase() + terrainType.slice(1)}
      </Text>
      
      {/* Progress indicator */}
      <mesh position={[0, heightScale + 0.5, range/2 + 0.2]} rotation={[0, Math.PI, 0]}>
        <planeGeometry args={[1, 0.2]} />
        <meshBasicMaterial color="#000000" opacity={0.7} transparent />
      </mesh>
      
      <Text
        position={[0, heightScale + 0.5, range/2 + 0.25]}
        rotation={[0, Math.PI, 0]}
        fontSize={0.05}
        color="white"
        anchorX="center"
        anchorY="middle"
      >
        {`Scan: ${Math.floor(scanProgress * 100)}%`}
      </Text>
    </group>
  );
};
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render } from '@testing-library/react';
import LlamaCoreXR from './LlamaCoreXR';

// Mock React Three Fiber
vi.mock('@react-three/fiber', () => ({
  useFrame: vi.fn((callback) => {
    callback({}, 0.1); // Call with mock state and delta
    return null;
  }),
}));

// Mock React Three XR
vi.mock('@react-three/xr', () => ({
  useXR: vi.fn(() => ({
    isPresenting: false,
  })),
}));

// Mock Three.js
vi.mock('three', () => ({
  Group: vi.fn(() => ({
    rotation: { y: 0 },
    add: vi.fn(),
  })),
  Mesh: vi.fn(() => ({
    position: { x: 0, y: 0, z: 0 },
  })),
  BoxGeometry: vi.fn(),
  SphereGeometry: vi.fn(),
  IcosahedronGeometry: vi.fn(),
  MeshStandardMaterial: vi.fn(() => ({
    color: { r: 0, g: 0, b: 0 },
  })),
  PointsMaterial: vi.fn(),
  BufferGeometry: vi.fn(() => ({
    setAttribute: vi.fn(),
  })),
  Float32BufferAttribute: vi.fn(),
  Points: vi.fn(() => ({
    rotation: { y: 0 },
  })),
  Color: vi.fn(() => ({
    lerpColors: vi.fn(() => ({ r: 0, g: 1, b: 0 })),
  })),
  MathUtils: {
    randFloatSpread: vi.fn((range) => range * Math.random() - range / 2),
  },
  DirectionalLight: vi.fn(),
  PointLight: vi.fn(),
}));

describe('LlamaCoreXR Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders without crashing', () => {
    const { container } = render(<LlamaCoreXR />);
    expect(container).toBeTruthy();
  });

  it('accepts position and scale props', () => {
    const position = [1, 2, 3];
    const scale = 2;
    
    const { container } = render(
      <LlamaCoreXR position={position} scale={scale} />
    );
    
    expect(container).toBeTruthy();
    // We can't easily check the Three.js props directly with this mock setup,
    // but we can verify it doesn't crash with props
  });

  it('handles health state changes', async () => {
    // We need to create a more sophisticated test to check internal state changes
    const useStateSpy = vi.spyOn(React, 'useState');
    
    render(<LlamaCoreXR />);
    
    // Check if useState was called for health
    expect(useStateSpy).toHaveBeenCalledWith(1);
    
    // Cleanup
    useStateSpy.mockRestore();
  });

  it('creates particle effects', () => {
    const useRefSpy = vi.spyOn(React, 'useRef');
    const useEffectSpy = vi.spyOn(React, 'useEffect');
    
    render(<LlamaCoreXR />);
    
    // Check if refs were created
    expect(useRefSpy).toHaveBeenCalled();
    
    // Check if useEffect was called to set up particles
    expect(useEffectSpy).toHaveBeenCalled();
    
    // Cleanup
    useRefSpy.mockRestore();
    useEffectSpy.mockRestore();
  });

  it('handles animation with useFrame', () => {
    const { useFrame } = require('@react-three/fiber');
    
    render(<LlamaCoreXR />);
    
    // Check if useFrame was called
    expect(useFrame).toHaveBeenCalled();
  });

  it('adapts to XR mode', () => {
    const { useXR } = require('@react-three/xr');
    
    // First render with isPresenting = false
    render(<LlamaCoreXR />);
    expect(useXR).toHaveReturnedWith({ isPresenting: false });
    
    // Mock XR presenting mode
    useXR.mockReturnValue({ isPresenting: true });
    
    // Render again with isPresenting = true
    render(<LlamaCoreXR />);
    expect(useXR).toHaveReturnedWith({ isPresenting: true });
  });
});
import React, { useRef, useEffect, useState } from 'react';
import { useFrame } from '@react-three/fiber';
import { useXR } from '@react-three/xr';
import * as THREE from 'three';
import { VisualizationProps } from '../../types';

// XR-optimized version of LlamaCore component
export const LlamaCoreXR: React.FC<VisualizationProps> = ({ position = [0, 0, 0], scale = 1 }) => {
  const groupRef = useRef<THREE.Group>(null);
  const [health, setHealth] = useState<number>(1);
  const particlesRef = useRef<THREE.Group>(null);
  const { isPresenting } = useXR();

  // Decrease health over time for the visual effect
  useEffect(() => {
    const intervalId = setInterval(() => {
      setHealth((prevHealth) => Math.max(0, prevHealth - 0.01));
    }, 100);

    return () => clearInterval(intervalId);
  }, []);

  // Reset health when VR mode is toggled
  useEffect(() => {
    setHealth(1);
  }, [isPresenting]);

  // Create particles for visual effect
  useEffect(() => {
    if (!particlesRef.current) return;
    
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    const numParticles = isPresenting ? 2000 : 5000; // Reduce particles in VR for performance
    
    for (let i = 0; i < numParticles; i++) {
      const x = THREE.MathUtils.randFloatSpread(5) * scale;
      const y = THREE.MathUtils.randFloatSpread(5) * scale;
      const z = THREE.MathUtils.randFloatSpread(5) * scale;
      vertices.push(x, y, z);
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    const material = new THREE.PointsMaterial({
      color: 0xff0000,
      size: 0.02 * scale,
      sizeAttenuation: true
    });
    
    const points = new THREE.Points(geometry, material);
    particlesRef.current.add(points);
    
    return () => {
      geometry.dispose();
      material.dispose();
    };
  }, [scale, isPresenting]);

  // Animation loop
  useFrame((_, delta: number) => {
    if (groupRef.current) {
      // Rotate the model
      groupRef.current.rotation.y += delta * 0.5;
    }
    
    if (particlesRef.current) {
      // Rotate particles
      particlesRef.current.rotation.y += delta * 0.2;
    }
  });

  return (
    <group position={position}>
      <group ref={groupRef.current} scale={scale}>
        {/* Main Llama body */}
        <mesh castShadow receiveShadow>
          <icosahedronGeometry args={[1, 1]} />
          <meshStandardMaterial 
            color={new THREE.Color().lerpColors(
              new THREE.Color(1, 0, 0),
              new THREE.Color(0, 1, 0),
              health
            )}
            metalness={0.5}
            roughness={0.5}
            transparent={true}
            opacity={Math.max(0.3, health)}
          />
        </mesh>
        
        {/* Simple eyes */}
        <mesh position={[0.4, 0.4, 0.7]} castShadow>
          <sphereGeometry args={[0.1, 16, 16]} />
          <meshStandardMaterial color="#ffffff" />
        </mesh>
        
        <mesh position={[-0.4, 0.4, 0.7]} castShadow>
          <sphereGeometry args={[0.1, 16, 16]} />
          <meshStandardMaterial color="#ffffff" />
        </mesh>
        
        {/* Particle system container */}
        <group ref={particlesRef} />
        
        {/* Add lights specific to this model */}
        <pointLight position={[0, 2, 2]} intensity={0.5} color="white" />
      </group>
      
      {/* XR interaction hint */}
      {isPresenting && (
        <mesh position={[0, 1.5, 0]} scale={0.2}>
          <sphereGeometry args={[0.1, 8, 8]} />
          <meshBasicMaterial color="#00ffff" />
        </mesh>
      )}
    </group>
  );
};
import React, { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import { useXR } from '@react-three/xr';
import * as THREE from 'three';
import { VisualizationProps } from '../../types';

interface ParticleAttributes {
  velocity: THREE.Vector3;
  acceleration: THREE.Vector3;
  color: THREE.Color;
  size: number;
  life: number;
  maxLife: number;
}

export const ParticleSystemXR: React.FC<VisualizationProps> = ({ position = [0, 0, 0], scale = 1 }) => {
  const { isPresenting } = useXR();
  const pointsRef = useRef<THREE.Points>(null);
  
  // Generate particles
  const { positions, colors, particles } = useMemo(() => {
    const particleCount = isPresenting ? 5000 : 10000;
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const particles: ParticleAttributes[] = [];
    
    for (let i = 0; i < particleCount; i++) {
      const pos = new THREE.Vector3(
        (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 2
      );
      
      positions[i * 3] = pos.x;
      positions[i * 3 + 1] = pos.y;
      positions[i * 3 + 2] = pos.z;
      
      const color = new THREE.Color().setHSL(
        Math.random(),
        0.8,
        0.5 + Math.random() * 0.5
      );
      
      colors[i * 3] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;
      
      particles.push({
        velocity: new THREE.Vector3(
          (Math.random() - 0.5) * 0.02,
          (Math.random() - 0.5) * 0.02,
          (Math.random() - 0.5) * 0.02
        ),
        acceleration: new THREE.Vector3(),
        color,
        size: (0.5 + Math.random() * 0.5) * scale,
        life: Math.random(),
        maxLife: 0.5 + Math.random() * 2
      });
    }
    
    return { positions, colors, particles };
  }, [isPresenting, scale]);
  
  // Animation loop
  useFrame((_, delta) => {
    if (!pointsRef.current) return;
    
    const positions = pointsRef.current.geometry.attributes.position;
    const colors = pointsRef.current.geometry.attributes.color;
    
    particles.forEach((particle, i) => {
      // Update life
      particle.life += delta;
      if (particle.life > particle.maxLife) {
        particle.life = 0;
        // Reset position
        const pos = new THREE.Vector3(
          positions.getX(i),
          positions.getY(i),
          positions.getZ(i)
        );
        pos.set(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        );
        positions.setXYZ(i, pos.x, pos.y, pos.z);
      }
      
      // Update velocity and position
      particle.velocity.add(particle.acceleration.multiplyScalar(delta));
      const pos = new THREE.Vector3(
        positions.getX(i),
        positions.getY(i),
        positions.getZ(i)
      );
      pos.add(particle.velocity);
      
      // Boundary check
      if (Math.abs(pos.x) > 1) particle.velocity.x *= -1;
      if (Math.abs(pos.y) > 1) particle.velocity.y *= -1;
      if (Math.abs(pos.z) > 1) particle.velocity.z *= -1;
      
      positions.setXYZ(i, pos.x, pos.y, pos.z);
      
      // Update color based on velocity
      const speed = particle.velocity.length();
      particle.color.setHSL(
        (speed * 10) % 1,
        0.8,
        0.5 + (speed * 5)
      );
      colors.setXYZ(i, particle.color.r, particle.color.g, particle.color.b);
    });
    
    positions.needsUpdate = true;
    colors.needsUpdate = true;
  });
  
  return (
    <points ref={pointsRef} position={position} scale={scale}>
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          count={positions.length / 3}
          array={positions}
          itemSize={3}
        />
        <bufferAttribute
          attach="attributes-color"
          count={colors.length / 3}
          array={colors}
          itemSize={3}
        />
      </bufferGeometry>
      <pointsMaterial
        size={0.02}
        vertexColors
        transparent
        depthWrite={false}
        blending={THREE.AdditiveBlending}
        sizeAttenuation
        onBeforeCompile={(shader: THREE.Shader) => {
          shader.vertexShader = shader.vertexShader.replace(
            'gl_PointSize = size;',
            'gl_PointSize = size * (300.0 / -mvPosition.z);'
          );
        }}
      />
    </points>
  );
};import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render } from '@testing-library/react';
import { TerrainMappingXR } from '../src/components/visualizations/TerrainMappingXR';

// Mock React Three Fiber
vi.mock('@react-three/fiber', () => ({
  useFrame: vi.fn((callback) => {
    callback({ clock: { getElapsedTime: () => 1.0 } }, 0.1); // Call with mock state and delta
    return null;
  }),
}));

// Mock React Three XR
vi.mock('@react-three/xr', () => ({
  useXR: vi.fn(() => ({
    isPresenting: false,
  })),
  useController: vi.fn(() => null),
  Interactive: ({ children }) => children,
}));

// Mock React Three Drei
vi.mock('@react-three/drei', () => ({
  Text: ({ children }) => children,
}));

// Mock Three.js
vi.mock('three', () => ({
  Mesh: vi.fn(() => ({
    position: { x: 0, y: 0, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    geometry: {
      attributes: {
        position: {
          array: new Float32Array(100),
          needsUpdate: false,
        },
      },
      computeVertexNormals: vi.fn(),
    },
    material: {
      displacementMap: true,
      displacementScale: 1.0,
    },
  })),
  Group: vi.fn(() => ({
    position: { x: 0, y: 0, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    children: [],
  })),
  Vector3: vi.fn((x = 0, y = 0, z = 0) => ({ x, y, z })),
  Color: vi.fn(() => ({
    setHSL: vi.fn().mockReturnThis(),
    r: 0, g: 0, b: 0,
  })),
  Float32BufferAttribute: vi.fn(),
  Points: vi.fn(() => ({
    geometry: {
      attributes: {
        position: {
          count: 100,
          getZ: vi.fn(() => 0),
          needsUpdate: false,
        },
        setAttribute: vi.fn(),
      },
    },
  })),
  PlaneGeometry: vi.fn(),
  BoxGeometry: vi.fn(),
  SphereGeometry: vi.fn(),
  MeshStandardMaterial: vi.fn(),
  PointsMaterial: vi.fn(),
  BufferGeometry: vi.fn(),
  DoubleSide: 'DoubleSide',
  MathUtils: {
    lerp: vi.fn((a, b, t) => a + (b - a) * t),
  },
  AdditiveBlending: 'AdditiveBlending',
  Shader: class {
    vertexShader: string = '';
    fragmentShader: string = '';
  },
}));

describe('TerrainMappingXR Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders without crashing', () => {
    const { container } = render(<TerrainMappingXR />);
    expect(container).toBeTruthy();
  });

  it('accepts position and scale props', () => {
    const position = [1, 2, 3];
    const scale = 2;
    
    const { container } = render(
      <TerrainMappingXR position={position} scale={scale} />
    );
    
    expect(container).toBeTruthy();
  });

  it('initializes with default terrain type', () => {
    const useStateSpy = vi.spyOn(React, 'useState');
    
    render(<TerrainMappingXR />);
    
    // Check if useState was called with 'mountains' as default
    expect(useStateSpy).toHaveBeenCalledWith('mountains');
    expect(useStateSpy).toHaveBeenCalledWith(0); // scanProgress
    expect(useStateSpy).toHaveBeenCalledWith(false); // interactMode
    
    // Cleanup
    useStateSpy.mockRestore();
  });

  it('generates height data based on terrain type', () => {
    const useMemoSpy = vi.spyOn(React, 'useMemo');
    
    render(<TerrainMappingXR />);
    
    // Check if useMemo was called to generate height data
    expect(useMemoSpy).toHaveBeenCalled();
    
    // Cleanup
    useMemoSpy.mockRestore();
  });

  it('sets up refs for terrain and scan elements', () => {
    const useRefSpy = vi.spyOn(React, 'useRef');
    
    render(<TerrainMappingXR />);
    
    // Check if useRef was called for terrain, scanBar, and dataPoints
    expect(useRefSpy).toHaveBeenCalledTimes(3);
    
    // Cleanup
    useRefSpy.mockRestore();
  });

  it('updates scan progress in animation frame', () => {
    const { useFrame } = require('@react-three/fiber');
    const setStateMock = vi.fn();
    React.useState = vi.fn().mockImplementation((initialState) => {
      if (initialState === 0) { // scanProgress
        return [0, setStateMock];
      }
      return [initialState, vi.fn()];
    });
    
    render(<TerrainMappingXR />);
    
    // Check if useFrame was called for animation
    expect(useFrame).toHaveBeenCalled();
    
    // Check if setState was called for scan progress
    expect(setStateMock).toHaveBeenCalled();
  });

  it('adapts resolution based on XR mode', () => {
    const { useXR } = require('@react-three/xr');
    
    // First test with isPresenting = false (higher resolution)
    render(<TerrainMappingXR />);
    
    // Mock XR presenting mode (should use lower resolution)
    useXR.mockReturnValue({ isPresenting: true });
    
    // Render again
    render(<TerrainMappingXR />);
  });

  it('handles terrain type toggle', () => {
    const setTerrainTypeMock = vi.fn();
    React.useState = vi.fn().mockImplementation((initialState) => {
      if (initialState === 'mountains') {
        return ['mountains', setTerrainTypeMock];
      }
      return [initialState, vi.fn()];
    });
    
    render(<TerrainMappingXR />);
    
    // Get access to the handleToggleTerrain function via mocking
    let handleToggleTerrain;
    const originalUseFrame = require('@react-three/fiber').useFrame;
    
    require('@react-three/fiber').useFrame.mockImplementation((callback) => {
      // Extract the function from the component
      const callbackString = callback.toString();
      handleToggleTerrain = callbackString.includes('handleToggleTerrain');
      return originalUseFrame(callback);
    });
    
    // Check if the function was defined
    expect(handleToggleTerrain).toBeTruthy();
    
    // Reset the mock
    require('@react-three/fiber').useFrame = originalUseFrame;
  });

  it('handles controller interaction in XR mode', () => {
    const { useXR, useController } = require('@react-three/xr');
    
    // Mock XR presenting mode with controller
    useXR.mockReturnValue({ isPresenting: true });
    useController.mockReturnValue({
      grip: {
        position: { x: 0, y: 0, z: 0 }
      }
    });
    
    // Mock interactMode state to true
    React.useState = vi.fn().mockImplementation((initialState) => {
      if (initialState === false) { // interactMode
        return [true, vi.fn()];
      }
      return [initialState, vi.fn()];
    });
    
    render(<TerrainMappingXR />);
    
    // This is testing that controller interaction doesn't crash
    // A more complex test would verify terrain modifications
    expect(true).toBeTruthy();
  });
});
import React from 'react';
import { motion } from 'framer-motion';
import { LoaderProps } from '../types';

export const Loader: React.FC<LoaderProps> = ({ message = 'Loading...' }) => {
  return (
    <div className="loader-container">
      <motion.div 
        className="loader"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.5 }}
      >
        <div className="spinner">
          <svg viewBox="0 0 50 50">
            <circle 
              className="path" 
              cx="25" 
              cy="25" 
              r="20" 
              fill="none" 
              strokeWidth="4"
            />
          </svg>
        </div>
        <motion.p 
          className="loading-message"
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
        >
          {message}
        </motion.p>
      </motion.div>
    </div>
  );
};

export default Loader;
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import WebGLContextHandler from '../src/components/utils/WebGLContextHandler';

// Mock canvas and WebGL context
const mockGetContext = vi.fn();
const mockGetSupportedExtensions = vi.fn();

// Mock createElement to provide our canvas mock
vi.spyOn(document, 'createElement').mockImplementation((tagName) => {
  if (tagName === 'canvas') {
    return {
      getContext: mockGetContext,
    } as unknown as HTMLCanvasElement;
  }
  return document.createElement(tagName);
});

describe('WebGLContextHandler Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorage.clear();
    
    // Default mock implementation for successful WebGL context
    mockGetContext.mockImplementation((contextType) => {
      if (contextType === 'webgl2' || contextType === 'webgl') {
        return {
          getSupportedExtensions: mockGetSupportedExtensions,
        };
      }
      return null;
    });
    
    // Default mock implementation for extensions
    mockGetSupportedExtensions.mockReturnValue([
      'OES_texture_float',
      'WEBGL_depth_texture',
      'OES_element_index_uint'
    ]);
  });

  it('renders children when WebGL is available', async () => {
    render(
      <WebGLContextHandler>
        <div data-testid="child-component">Child Component</div>
      </WebGLContextHandler>
    );
    
    // Initially shows loader
    expect(screen.getByText('Checking WebGL support...')).toBeInTheDocument();
    
    // Wait for WebGL check to complete
    await vi.waitFor(() => {
      expect(screen.getByTestId('child-component')).toBeInTheDocument();
    });
  });

  it('displays error when WebGL is not supported', async () => {
    // Mock WebGL context as not available
    mockGetContext.mockReturnValue(null);
    
    render(
      <WebGLContextHandler>
        <div data-testid="child-component">Child Component</div>
      </WebGLContextHandler>
    );
    
    // Wait for error message
    await vi.waitFor(() => {
      expect(screen.getByText('WebGL Error')).toBeInTheDocument();
      expect(screen.getByText('WebGL is not supported in your browser')).toBeInTheDocument();
    });
    
    // Child component should not be rendered
    expect(screen.queryByTestId('child-component')).not.toBeInTheDocument();
  });

  it('displays warnings when preferred extensions are missing', async () => {
    // Mock with missing preferred extensions
    mockGetSupportedExtensions.mockReturnValue(['OES_element_index_uint']);
    
    render(
      <WebGLContextHandler>
        <div data-testid="child-component">Child Component</div>
      </WebGLContextHandler>
    );
    
    // Wait for component to finish loading
    await vi.waitFor(() => {
      expect(screen.getByTestId('child-component')).toBeInTheDocument();
    });
    
    // Warning should be shown
    expect(screen.getByText(/Your browser is missing some WebGL extensions/)).toBeInTheDocument();
  });

  it('allows dismissing warnings', async () => {
    // Mock with missing preferred extensions
    mockGetSupportedExtensions.mockReturnValue(['OES_element_index_uint']);
    
    render(
      <WebGLContextHandler>
        <div data-testid="child-component">Child Component</div>
      </WebGLContextHandler>
    );
    
    // Wait for component to finish loading
    await vi.waitFor(() => {
      expect(screen.getByTestId('child-component')).toBeInTheDocument();
    });
    
    // Warning should be shown
    const dismissButton = screen.getByText('Dismiss');
    expect(dismissButton).toBeInTheDocument();
    
    // Click dismiss button
    fireEvent.click(dismissButton);
    
    // Warning should be gone
    expect(screen.queryByText(/Your browser is missing some WebGL extensions/)).not.toBeInTheDocument();
  });

  it('shows browser-specific instructions for Chrome', async () => {
    // Mock WebGL context as not available
    mockGetContext.mockReturnValue(null);
    
    // Mock userAgent for Chrome
    Object.defineProperty(navigator, 'userAgent', {
      value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
      configurable: true
    });
    
    render(
      <WebGLContextHandler>
        <div>Child Component</div>
      </WebGLContextHandler>
    );
    
    // Wait for error message with Chrome instructions
    await vi.waitFor(() => {
      expect(screen.getByText('For Chrome users:')).toBeInTheDocument();
      expect(screen.getByText(/chrome:\/\/flags/)).toBeInTheDocument();
    });
  });
});
import React, { useEffect, useState } from 'react';
import { Loader } from '../Loader';

interface WebGLContextHandlerProps {
  children: React.ReactNode;
}

interface WebGLError {
  type: 'WEBGL_UNSUPPORTED' | 'WEBGL_ERROR' | 'EXTENSION_MISSING';
  message: string;
  missingExtensions?: string[];
}

const WebGLContextHandler: React.FC<WebGLContextHandlerProps> = ({ children }) => {
  const [isWebGLAvailable, setIsWebGLAvailable] = useState<boolean | null>(null);
  const [error, setError] = useState<WebGLError | null>(null);
  const [hasWarnings, setHasWarnings] = useState<boolean>(false);

  useEffect(() => {
    const checkWebGLSupport = (): void => {
      try {
        const canvas = document.createElement('canvas');
        
        // Try WebGL2 first, then fall back to WebGL1
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        
        if (!gl) {
          setError({
            type: 'WEBGL_UNSUPPORTED',
            message: 'WebGL is not supported in your browser'
          });
          setIsWebGLAvailable(false);
          return;
        }

        // Check for required and optional extensions
        const extensions = gl.getSupportedExtensions() || [];
        
        // Critical extensions that we absolutely need
        const criticalExtensions = [];
        
        // Preferred extensions that enhance experience but we can work without
        const preferredExtensions = ['OES_texture_float', 'WEBGL_depth_texture'];
        
        const missingCritical = criticalExtensions.filter(
          ext => !extensions.includes(ext)
        );

        const missingPreferred = preferredExtensions.filter(
          ext => !extensions.includes(ext)
        );
        
        // If critical extensions are missing, show an error
        if (missingCritical.length > 0) {
          setError({
            type: 'EXTENSION_MISSING',
            message: `Missing critical WebGL extensions: ${missingCritical.join(', ')}`,
            missingExtensions: missingCritical
          });
          setIsWebGLAvailable(false);
          return;
        }
        
        // If only preferred extensions are missing, show a warning but continue
        if (missingPreferred.length > 0) {
          setHasWarnings(true);
          console.warn(`Missing preferred WebGL extensions: ${missingPreferred.join(', ')}. Some visual features may be limited.`);
          // Store this in localStorage to avoid showing the warning again
          localStorage.setItem('webgl-extension-warning', JSON.stringify({
            warned: true,
            missingExtensions: missingPreferred
          }));
        }
        
        setIsWebGLAvailable(true);
      } catch (err) {
        setError({
          type: 'WEBGL_ERROR',
          message: err instanceof Error ? err.message : 'Unknown WebGL error'
        });
        setIsWebGLAvailable(false);
      }
    };
    
    checkWebGLSupport();
  }, []);

  const getBrowserSpecificInstructions = () => {
    const browser = detectBrowser();
    switch (browser) {
      case 'chrome':
        return (
          <>
            <p>For Chrome users:</p>
            <ol>
              <li>Type <code>chrome://flags</code> in your address bar</li>
              <li>Search for "WebGL" and enable "Override software rendering list"</li>
              <li>Restart Chrome</li>
            </ol>
          </>
        );
      case 'firefox':
        return (
          <>
            <p>For Firefox users:</p>
            <ol>
              <li>Type <code>about:config</code> in your address bar</li>
              <li>Search for <code>webgl.force-enabled</code> and set it to <code>true</code></li>
              <li>Restart Firefox</li>
            </ol>
          </>
        );
      default:
        return (
          <p>Try updating your graphics drivers or using a different browser such as Chrome or Firefox.</p>
        );
    }
  };

  const detectBrowser = () => {
    const userAgent = navigator.userAgent.toLowerCase();
    if (userAgent.indexOf('chrome') > -1) return 'chrome';
    if (userAgent.indexOf('firefox') > -1) return 'firefox';
    if (userAgent.indexOf('safari') > -1) return 'safari';
    if (userAgent.indexOf('edge') > -1) return 'edge';
    return 'unknown';
  };

  const dismissWarning = () => {
    setHasWarnings(false);
  };

  if (isWebGLAvailable === null) {
    return <Loader message="Checking WebGL support..." />;
  }

  if (!isWebGLAvailable) {
    return (
      <div className="webgl-error">
        <h2>WebGL Error</h2>
        <p>{error?.message || 'Unable to initialize WebGL'}</p>
        <div className="webgl-help">
          {getBrowserSpecificInstructions()}
        </div>
        <p>If you continue to experience issues, your device may not support WebGL or may have it disabled.</p>
      </div>
    );
  }

  return (
    <>
      {hasWarnings && (
        <div className="webgl-warning">
          <p>
            <strong>Note:</strong> Your browser is missing some WebGL extensions. 
            Some visual features may be limited or appear different.
          </p>
          <button onClick={dismissWarning}>Dismiss</button>
        </div>
      )}
      {children}
    </>
  );
};

export default WebGLContextHandler;
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render } from '@testing-library/react';
import XRMenu from './XRMenu';
import * as THREE from 'three';

// Mock React Three XR
vi.mock('@react-three/xr', () => ({
  Interactive: ({ children, onSelect }: { children: React.ReactNode; onSelect: () => void }) => (
    <div data-testid="interactive" onClick={() => onSelect()}>
      {children}
    </div>
  ),
}));

// Mock React Three Drei
vi.mock('@react-three/drei', () => ({
  Text: ({ children, ...props }: { children: React.ReactNode; [key: string]: any }) => (
    <div data-testid="text" {...props}>
      {children}
    </div>
  ),
}));

// Mock Three.js
vi.mock('three', () => {
  return {
    Vector3: vi.fn((...args) => ({
      ...args,
    })),
  };
});

describe('XRMenu Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders without crashing', () => {
    const onTeleport = vi.fn();
    const { container } = render(<XRMenu onTeleport={onTeleport} />);
    expect(container).toBeTruthy();
  });

  it('renders menu options', () => {
    const onTeleport = vi.fn();
    const { getAllByTestId } = render(<XRMenu onTeleport={onTeleport} />);
    
    // Should have 5 interactive menu options plus 1 help text
    const interactiveElements = getAllByTestId('interactive');
    expect(interactiveElements.length).toBe(5);
    
    const textElements = getAllByTestId('text');
    // 5 menu items + 1 help text
    expect(textElements.length).toBe(6);
    
    // Check specific menu items
    expect(textElements.some(el => el.textContent === 'LlamaCore')).toBe(true);
    expect(textElements.some(el => el.textContent === 'Particles')).toBe(true);
    expect(textElements.some(el => el.textContent === 'Network')).toBe(true);
    expect(textElements.some(el => el.textContent === 'Terrain')).toBe(true);
    expect(textElements.some(el => el.textContent === 'Neural')).toBe(true);
  });

  it('calls onTeleport when menu item is selected', () => {
    const onTeleport = vi.fn();
    const { getAllByTestId } = render(<XRMenu onTeleport={onTeleport} />);
    
    const interactiveElements = getAllByTestId('interactive');
    
    // Click the first menu item
    interactiveElements[0].click();
    
    // Check if onTeleport was called with a Vector3
    expect(onTeleport).toHaveBeenCalled();
    expect(THREE.Vector3).toHaveBeenCalled();
  });

  it('passes different positions to onTeleport for each menu item', () => {
    const onTeleport = vi.fn();
    const { getAllByTestId } = render(<XRMenu onTeleport={onTeleport} />);
    
    const interactiveElements = getAllByTestId('interactive');
    
    // Click each menu item and store the positions
    const positions = [];
    
    for (let i = 0; i < interactiveElements.length; i++) {
      interactiveElements[i].click();
      positions.push(onTeleport.mock.calls[i][0]);
    }
    
    // Check that each position is different using a proper map function
    const uniquePositions = new Set(positions.map((pos) => JSON.stringify(pos)));
    expect(uniquePositions.size).toBe(positions.length);
  });

  it('includes help text', () => {
    const onTeleport = vi.fn();
    const { getAllByTestId } = render(<XRMenu onTeleport={onTeleport} />);
    
    const textElements = getAllByTestId('text');
    
    // Find the help text
    const helpText = textElements.find(el => 
      el.textContent === 'Select a destination to teleport'
    );
    
    expect(helpText).toBeTruthy();
  });

  it('positions menu items correctly', () => {
    const onTeleport = vi.fn();
    const { getAllByTestId } = render(<XRMenu onTeleport={onTeleport} />);
    
    const menuItems = getAllByTestId('interactive');
    
    // Check that menu items have different positions with null check
    const positions = menuItems.map(item => {
      const textElement = item.querySelector('[data-testid="text"]');
      return textElement?.getAttribute('position') || '';
    });
    const uniquePositions = new Set(positions.filter(pos => pos !== ''));
    
    // Each menu item should have a unique position
    expect(uniquePositions.size).toBeGreaterThan(1);
  });
});
import React from 'react';
import { Interactive } from '@react-three/xr';
import { Text } from '@react-three/drei';
import * as THREE from 'three';

interface XRMenuProps {
  onTeleport: (position: THREE.Vector3) => void;
}

interface MenuOption {
  id: string;
  label: string;
  position: [number, number, number];
}

const XRMenu: React.FC<XRMenuProps> = ({ onTeleport }) => {
  const menuOptions: MenuOption[] = [
    { id: 'llama', label: 'LlamaCore', position: [-4, 1.5, -3] },
    { id: 'particles', label: 'Particles', position: [0, 1.5, -3] },
    { id: 'network', label: 'Network', position: [4, 1.5, -3] },
    { id: 'terrain', label: 'Terrain', position: [-4, 1.5, -6] },
    { id: 'neural', label: 'Neural', position: [4, 1.5, -6] },
  ];

  const handleTeleport = (position: [number, number, number]): void => {
    onTeleport(new THREE.Vector3(...position));
  };

  return (
    <group position={[0, 1, 0]}>
      {menuOptions.map((option) => (
        <Interactive
          key={option.id}
          onSelect={() => handleTeleport(option.position)}
        >
          <group position={option.position}>
            <mesh>
              <boxGeometry args={[0.3, 0.1, 0.05]} />
              <meshStandardMaterial color="#4488ff" />
            </mesh>
            <Text
              position={[0, 0.1, 0]}
              fontSize={0.1}
              color="white"
              anchorX="center"
              anchorY="middle"
            >
              {option.label}
            </Text>
          </group>
        </Interactive>
      ))}
      
      {/* Help text */}
      <Text
        position={[0, 2, -4]}
        fontSize={0.15}
        color="white"
        anchorX="center"
        anchorY="middle"
        maxWidth={2}
      >
        Select a destination to teleport
      </Text>
    </group>
  );
};

export default XRMenu;
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { SceneProps } from '../types';

const Scene: React.FC<SceneProps> = ({ width, height }) => {
    const mountRef = useRef<HTMLDivElement>(null);
    const sceneRef = useRef<THREE.Scene>();
    const cameraRef = useRef<THREE.PerspectiveCamera>();
    const rendererRef = useRef<THREE.WebGLRenderer>();
    const controlsRef = useRef<OrbitControls>();

    useEffect(() => {
        if (!mountRef.current) return;

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });

        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        mountRef.current.appendChild(renderer.domElement);

        // Camera positioning
        camera.position.z = 5;

        // Controls setup
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 1;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2;

        // Store references
        sceneRef.current = scene;
        cameraRef.current = camera;
        rendererRef.current = renderer;
        controlsRef.current = controls;

        // Animation loop
        const animate = () => {
            requestAnimationFrame(animate);
            
            if (controlsRef.current) {
                controlsRef.current.update();
            }
            
            if (rendererRef.current && sceneRef.current && cameraRef.current) {
                rendererRef.current.render(sceneRef.current, cameraRef.current);
            }
        };

        animate();

        // Cleanup
        return () => {
            if (mountRef.current && rendererRef.current) {
                mountRef.current.removeChild(rendererRef.current.domElement);
            }
            
            if (rendererRef.current) {
                rendererRef.current.dispose();
            }
            
            if (controlsRef.current) {
                controlsRef.current.dispose();
            }
        };
    }, [width, height]);

    // Handle window resize
    useEffect(() => {
        const handleResize = () => {
            if (cameraRef.current && rendererRef.current) {
                cameraRef.current.aspect = width / height;
                cameraRef.current.updateProjectionMatrix();
                rendererRef.current.setSize(width, height);
            }
        };

        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [width, height]);

    return <div ref={mountRef} />;
};

export default Scene;import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import Navigation from './Navigation';

// Mock useLocation
vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom');
  return {
    ...actual,
    useLocation: () => ({
      pathname: '/'
    })
  };
});

describe('Navigation Component', () => {
  beforeEach(() => {
    window.scrollY = 0;
    // Reset mocks
    vi.clearAllMocks();
  });

  it('renders correctly with WebXR support', () => {
    render(
      <BrowserRouter>
        <Navigation webXRSupported={true} />
      </BrowserRouter>
    );

    // Check if the logo is rendered
    expect(screen.getByText('WebXR Portfolio')).toBeInTheDocument();
    
    // Check if both links are rendered
    expect(screen.getByText('Desktop')).toBeInTheDocument();
    expect(screen.getByText('Try in VR/AR')).toBeInTheDocument();
    
    // "VR/AR Not Supported" text should not be present
    expect(screen.queryByText('VR/AR Not Supported')).not.toBeInTheDocument();
  });

  it('renders correctly without WebXR support', () => {
    render(
      <BrowserRouter>
        <Navigation webXRSupported={false} />
      </BrowserRouter>
    );
    
    expect(screen.getByText('WebXR Portfolio')).toBeInTheDocument();
    expect(screen.getByText('Desktop')).toBeInTheDocument();
    
    // "Try in VR/AR" link should not be present
    expect(screen.queryByText('Try in VR/AR')).not.toBeInTheDocument();
    
    // "VR/AR Not Supported" text should be present
    expect(screen.getByText('VR/AR Not Supported')).toBeInTheDocument();
  });

  it('handles mobile menu toggling', () => {
    render(
      <BrowserRouter>
        <Navigation webXRSupported={true} />
      </BrowserRouter>
    );
    
    // Mobile menu should initially be closed
    expect(screen.queryByText('Desktop View')).not.toBeInTheDocument();
    
    // Click menu toggle
    const menuToggle = document.querySelector('.menu-toggle');
    expect(menuToggle).toBeInTheDocument();
    
    if (menuToggle) {
      fireEvent.click(menuToggle);
      
      // Mobile menu should now be visible
      expect(screen.getByText('Desktop View')).toBeInTheDocument();
      expect(screen.getByText('VR/AR Experience')).toBeInTheDocument();
      
      // Click again to close
      fireEvent.click(menuToggle);
      
      // Mobile menu should be closed
      expect(screen.queryByText('Desktop View')).not.toBeInTheDocument();
    }
  });

  it('updates style when scrolled', () => {
    render(
      <BrowserRouter>
        <Navigation webXRSupported={true} />
      </BrowserRouter>
    );
    
    // Initially not scrolled
    const nav = document.querySelector('.navigation');
    expect(nav).not.toHaveClass('scrolled');
    
    // Simulate scroll
    window.scrollY = 100;
    fireEvent.scroll(window);
    
    // Should have scrolled class
    expect(nav).toHaveClass('scrolled');
  });
});
import React, { useState, useEffect } from 'react';
import { Link, useLocation } from 'react-router-dom';
import { motion } from 'framer-motion';
import { NavigationProps } from '../types';

export const Navigation: React.FC<NavigationProps> = ({ webXRSupported }) => {
  const location = useLocation();
  const [scrolled, setScrolled] = useState<boolean>(false);
  const [menuOpen, setMenuOpen] = useState<boolean>(false);

  useEffect(() => {
    const handleScroll = (): void => {
      setScrolled(window.scrollY > 50);
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  return (
    <motion.nav 
      className={`navigation ${scrolled ? 'scrolled' : ''}`}
      initial={{ y: -100 }}
      animate={{ y: 0 }}
      transition={{ type: 'spring', stiffness: 300, damping: 30 }}
    >
      <div className="nav-content">
        <Link to="/" className="nav-logo">
          WebXR Portfolio
        </Link>
        
        <div className="nav-links">
          <Link to="/" className={location.pathname === '/' ? 'active' : ''}>
            Desktop
          </Link>
          
          {webXRSupported && (
            <Link to="/xr" className={location.pathname === '/xr' ? 'active' : ''}>
              Try in VR/AR
            </Link>
          )}
          
          {!webXRSupported && (
            <span className="xr-unsupported">
              VR/AR Not Supported
            </span>
          )}
        </div>
        
        <button 
          className={`menu-toggle ${menuOpen ? 'open' : ''}`}
          onClick={() => setMenuOpen(!menuOpen)}
        >
          <span></span>
          <span></span>
          <span></span>
        </button>
      </div>
      
      {/* Mobile menu */}
      {menuOpen && (
        <motion.div
          className="mobile-menu"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <Link to="/" onClick={() => setMenuOpen(false)}>
            Desktop View
          </Link>
          {webXRSupported && (
            <Link to="/xr" onClick={() => setMenuOpen(false)}>
              VR/AR Experience
            </Link>
          )}
        </motion.div>
      )}
    </motion.nav>
  );
};

export default Navigation;
// src/components/GemmaDashboard.tsx
import React, { useState } from 'react';
import { Canvas } from '@react-three/fiber';
import GemmaScene from './GemmaScene';
import ThreeJSErrorBoundary from './ErrorBoundary'; // Your existing error boundary
import {  } from "module";
//import { llamaStackClient } from '../your-llama-stack-client-setup'; // Import YOUR configured client

interface Message {
    role: 'user' | 'assistant',
    content: string
}
interface DashboardProps {}

const Dashboard: React.FC<DashboardProps> = () => {
  const [prompt, setPrompt] = useState('');
  const [response, setResponse] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Placeholder for communication with Llama Stack
  const sendPromptToGemma = async (userPrompt: string) => {

    const userMessage: Message = {role: 'user', content: userPrompt}
    setMessages([...messages, userMessage])
    setIsLoading(true);
    setError(null);
    try {
      // Replace this with your actual llama-stack-client call
      // const result = await llamaStackClient.ask({ prompt: userPrompt, model: 'gemma:7b' });
      // setResponse(result.response); // Assuming the response is in result.response
      //FOR TESTING WITHOUT BACKEND
        const result = {response: "This is a placeholder. Replace the try block with your backend call"}
        setResponse(result.response)

        const assistantMessage: Message = { role: 'assistant', content: result.response}
        setMessages(prev => [...prev, assistantMessage])
    } catch (error: any) {
      setError(error.message || 'An unexpected error occurred');
    } finally {
        setIsLoading(false)
        setPrompt('')
    }
  };

  const handleSubmit = (e: React.FormEvent) => {
      e.preventDefault();
      sendPromptToGemma(prompt)
  }

  return (
    <div style={{ display: 'flex', height: '100vh' }}>
      {/* Sidebar (Optional) */}
      <div style={{ width: '250px', backgroundColor: '#f0f0f0', padding: '20px' }}>
        Sidebar Content (e.g., settings, history)
      </div>

      {/* Main Content Area */}
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
        {/* Top Bar (Optional) */}
        <div style={{ padding: '10px', backgroundColor: '#ddd' }}>
          Dashboard Header
        </div>

        {/* Chat Area */}
        <div style={{flex: 1, display: 'flex', flexDirection: 'column', padding: '4rem'}}>
            <div style={{flex: 1, overflowY: 'scroll', marginBottom: '1rem'}}>
                {messages.map((msg, index) => (
                    <div key={index} className={msg.role === 'user' ? 'user-message' : 'assistant-message'}>
                        <p><strong>{msg.role.toUpperCase()}:</strong> {msg.content}</p>
                    </div>
                ))}
            </div>
            <form onSubmit={handleSubmit} style={{display: 'flex', gap: '1rem'}}>
                <input
                  type="text"
                  value={prompt}
                  onChange={(e) => setPrompt(e.target.value)}
                  placeholder="Enter your prompt..."
                  style={{flexGrow: 1, padding: '.5rem'}}
                  disabled={isLoading}
                />
                <button type="submit" disabled={isLoading} style={{padding: '.5rem', cursor: 'pointer'}}>
                    {isLoading? "Loading..." : "Submit"}
                </button>
            </form>
            {error && <div style={{color: 'red', marginTop: '1rem'}}>{error}</div>}
        </div>
      </div>

         {/* 3D Scene Area */}
         <div style={{ width: '500px', height: '500px' }}>
          <ThreeJSErrorBoundary>
            <Canvas>
                <GemmaScene />
            </Canvas>
          </ThreeJSErrorBoundary>
        </div>
    </div>
  );
};

export default Dashboard;import React, { useRef, useMemo, useState, useEffect } from 'react';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { useXR, Interactive, Controllers, Hands, VRButton } from '@react-three/xr';
import { PointerLockControls } from '@react-three/drei';
import * as THREE from 'three';
import * as d3 from 'd3';
import { NetworkVisualizationXR } from './NetworkVisualizationXR';

// Xbox One Controller Support
const XboxControllerInput = ({ onMove, onSelect }) => {
  const [controllers, setControllers] = useState([]);
  
  useEffect(() => {
    // Function to handle gamepad connection/disconnection
    const handleGamepadConnected = (event) => {
      console.log('Gamepad connected:', event.gamepad);
      updateGamepads();
    };

    const handleGamepadDisconnected = (event) => {
      console.log('Gamepad disconnected:', event.gamepad);
      updateGamepads();
    };

    // Function to update the list of connected gamepads
    const updateGamepads = () => {
      const gamepads = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
      setControllers(gamepads);
    };

    // Add event listeners
    window.addEventListener('gamepadconnected', handleGamepadConnected);
    window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);

    // Initial check for already connected gamepads
    updateGamepads();

    // Cleanup
    return () => {
      window.removeEventListener('gamepadconnected', handleGamepadConnected);
      window.removeEventListener('gamepaddisconnected', handleGamepadDisconnected);
    };
  }, []);

  // Process controller inputs each frame
  useFrame(() => {
    controllers.forEach(gamepad => {
      // Check if it's an Xbox controller (or compatible)
      if (gamepad.id.includes('Xbox') || gamepad.mapping === 'standard') {
        // Left stick for movement
        const leftStickX = gamepad.axes[0]; // Left/Right
        const leftStickY = gamepad.axes[1]; // Forward/Backward
        
        // Only process movement if stick is moved beyond deadzone
        if (Math.abs(leftStickX) > 0.1 || Math.abs(leftStickY) > 0.1) {
          onMove({
            x: leftStickX * 0.05,
            y: 0,
            z: leftStickY * 0.05
          });
        }
        
        // A button for selection (button index 0)
        if (gamepad.buttons[0].pressed) {
          onSelect();
        }
      }
    });
  });
  
  return null;
};

// Keyboard and Mouse Controls
const KeyboardMouseControls = ({ enabled = true }) => {
  const { camera } = useThree();
  const controlsRef = useRef();
  const [movement, setMovement] = useState({
    forward: false,
    backward: false,
    left: false,
    right: false,
    speed: 0.1
  });
  
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (!enabled) return;
      switch (e.code) {
        case 'KeyW': setMovement(m => ({ ...m, forward: true })); break;
        case 'KeyS': setMovement(m => ({ ...m, backward: true })); break;
        case 'KeyA': setMovement(m => ({ ...m, left: true })); break;
        case 'KeyD': setMovement(m => ({ ...m, right: true })); break;
      }
    };
    
    const handleKeyUp = (e) => {
      switch (e.code) {
        case 'KeyW': setMovement(m => ({ ...m, forward: false })); break;
        case 'KeyS': setMovement(m => ({ ...m, backward: false })); break;
        case 'KeyA': setMovement(m => ({ ...m, left: false })); break;
        case 'KeyD': setMovement(m => ({ ...m, right: false })); break;
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [enabled]);
  
  useFrame(() => {
    if (!enabled || !controlsRef.current) return;
    
    const direction = new THREE.Vector3();
    const frontVector = new THREE.Vector3(0, 0, Number(movement.backward) - Number(movement.forward));
    const sideVector = new THREE.Vector3(Number(movement.left) - Number(movement.right), 0, 0);
    
    direction
      .subVectors(frontVector, sideVector)
      .normalize()
      .multiplyScalar(movement.speed);
      
    if (controlsRef.current.isLocked) {
      controlsRef.current.moveRight(-direction.x);
      controlsRef.current.moveForward(-direction.z);
    }
  });
  
  return <PointerLockControls ref={controlsRef} />;
};

// Portal Component
const Portal = ({ position, rotation, title, thumbnail, onClick }) => {
  const [hovered, setHovered] = useState(false);
  
  return (
    <group position={position} rotation={rotation}>
      <Interactive onSelect={onClick} onHover={() => setHovered(true)} onBlur={() => setHovered(false)}>
        <mesh position={[0, 0, 0]}>
          <planeGeometry args={[1.5, 2]} />
          <meshBasicMaterial color={hovered ? "#4488ff" : "#2266dd"} side={THREE.DoubleSide} />
        </mesh>
        
        {/* Thumbnail */}
        <mesh position={[0, 0.3, 0.01]}>
          <planeGeometry args={[1.3, 1.3]} />
          <meshBasicMaterial map={thumbnail} side={THREE.DoubleSide} />
        </mesh>
        
        {/* Title */}
        <mesh position={[0, -0.7, 0.01]}>
          <planeGeometry args={[1.3, 0.3]} />
          <meshBasicMaterial color="#000000" side={THREE.DoubleSide} />
          <Text position={[0, 0, 0.02]} color="white" fontSize={0.15}>{title}</Text>
        </mesh>
      </Interactive>
    </group>
  );
};

// Text Component (simplified version)
const Text = ({ children, position, color = "white", fontSize = 0.1 }) => {
  return (
    <mesh position={position}>
      <textGeometry args={[children, { font: 'helvetiker', size: fontSize, height: 0.01 }]} />
      <meshBasicMaterial color={color} />
    </mesh>
  );
};

// Environment component with navigation and portals
const Environment = () => {
  const { isPresenting } = useXR();
  const [currentView, setCurrentView] = useState('menu');
  const [position, setPosition] = useState(new THREE.Vector3(0, 1.6, 0));
  const thumbnailTexture = useMemo(() => {
    const texture = new THREE.TextureLoader().load('/placeholder-thumbnail.jpg');
    return texture;
  }, []);
  
  // Handler for controller/keyboard movement
  const handleMove = (movement) => {
    setPosition(prev => new THREE.Vector3(
      prev.x + movement.x,
      prev.y + movement.y,
      prev.z + movement.z
    ));
  };
  
  return (
    <>
      {/* Xbox controller support */}
      <XboxControllerInput 
        onMove={handleMove} 
        onSelect={() => console.log('Controller select')} 
      />
      
      {/* Mouse/Keyboard controls (disabled in VR mode) */}
      <KeyboardMouseControls enabled={!isPresenting} />
      
      {/* User position/camera */}
      <group position={position}>
        {/* Environment elements will be positioned relative to this */}
      </group>
      
      {/* Menu portals - only show in menu view */}
      {currentView === 'menu' && (
        <>
          <Portal 
            position={[-2, 1.5, -3]} 
            rotation={[0, 0.3, 0]} 
            title="Network Visualization" 
            thumbnail={thumbnailTexture}
            onClick={() => setCurrentView('network')}
          />
          
          <Portal 
            position={[0, 1.5, -3]} 
            rotation={[0, 0, 0]} 
            title="Data Analytics" 
            thumbnail={thumbnailTexture}
            onClick={() => setCurrentView('analytics')}
          />
          
          <Portal 
            position={[2, 1.5, -3]} 
            rotation={[0, -0.3, 0]} 
            title="3D Models" 
            thumbnail={thumbnailTexture}
            onClick={() => setCurrentView('models')}
          />
        </>
      )}
      
      {/* Components */}
      {currentView === 'network' && (
        <>
          <NetworkVisualizationXR position={[0, 1, -3]} scale={2} />
          <mesh position={[0, 2.5, -3]} onClick={() => setCurrentView('menu')}>
            <planeGeometry args={[1, 0.3]} />
            <meshBasicMaterial color="#ff3333" />
            <Text position={[0, 0, 0.01]} color="white">Back to Menu</Text>
          </mesh>
        </>
      )}

      {/* Placeholder for other views */}
      {currentView === 'analytics' && (
        <mesh position={[0, 1.5, -3]} onClick={() => setCurrentView('menu')}>
          <boxGeometry args={[1, 1, 1]} />
          <meshStandardMaterial color="orange" />
          <Text position={[0, 1.2, 0]} color="white">Analytics View (Placeholder)</Text>
          <Text position={[0, 0.8, 0]} color="white">Click to return to menu</Text>
        </mesh>
      )}
      
      {currentView === 'models' && (
        <mesh position={[0, 1.5, -3]} onClick={() => setCurrentView('menu')}>
          <sphereGeometry args={[1, 32, 32]} />
          <meshStandardMaterial color="green" />
          <Text position={[0, 1.2, 0]} color="white">3D Models View (Placeholder)</Text>
          <Text position={[0, 0.8, 0]} color="white">Click to return to menu</Text>
        </mesh>
      )}
      
      {/* Environment lighting */}
      <ambientLight intensity={0.5} />
      <directionalLight position={[10, 10, 5]} intensity={1} />
      
      {/* Sky/background */}
      <mesh>
        <sphereGeometry args={[50, 32, 32]} />
        <meshBasicMaterial color="#101020" side={THREE.BackSide} />
      </mesh>
      
      {/* Floor */}
      <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0, 0]}>
        <planeGeometry args={[50, 50]} />
        <meshStandardMaterial color="#222233" />
      </mesh>
    </>
  );
};

// Main App Component
export const WebXRTechDemo = () => {
  return (
    <div style={{ width: '100vw', height: '100vh', position: 'absolute', top: 0, left: 0 }}>
      <VRButton />
      <Canvas>
        <Environment />
        <Controllers />
        <Hands />
      </Canvas>
    </div>
  );
};

export default WebXRTechDemo;
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import Loader from './Loader';

// Mock framer-motion to avoid animation issues in tests
vi.mock('framer-motion', () => ({
  motion: {
    div: ({ children, ...props }: any) => <div {...props}>{children}</div>,
    p: ({ children, ...props }: any) => <p {...props}>{children}</p>
  }
}));

describe('Loader Component', () => {
  it('renders with default message', () => {
    render(<Loader />);
    
    // Check if the default loading message is displayed
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('renders with custom message', () => {
    const customMessage = 'Custom loading message';
    render(<Loader message={customMessage} />);
    
    // Check if the custom message is displayed
    expect(screen.getByText(customMessage)).toBeInTheDocument();
  });
});import React, { useState } from 'react';
import { Canvas } from '@react-three/fiber';
import { 
  VRButton, 
  ARButton, 
  XR, 
  Hands, 
  Controllers, 
  Interactive, 
  RayGrab,
  useXR 
} from '@react-three/xr';
import { 
  Environment, 
  Text, 
  Sky, 
  Stars,
  Billboard as DreiBoard
} from '@react-three/drei';
import * as THREE from 'three';
import { XRNavigatorProps } from '../types';

// Import visualization components with correct names
import { LlamaCoreXR } from '../components/visualizations/LlamaCoreXR';
import { ParticleSystemXR } from '../components/visualizations/ParticleSystemXR';
import { NetworkVisualizationXR } from '../components/visualizations/NetworkVisualizationXR';
import { TerrainMappingXR } from '../components/visualizations/TerrainMappingXR';
import { NeuralNetworkXR } from '../components/visualizations/NeuralNetworkXR';
import { PortfolioEnvironment } from '../components/environment/PortfolioEnvironment';
import XRMenu from '../components/xr/XRMenu';

type ExperienceType = 'llama' | 'particles' | 'network' | 'terrain' | 'neural' | null;

const XRNavigator: React.FC<XRNavigatorProps> = ({ onTeleport }) => {
  const { player } = useXR();
  
  return (
    <XRMenu onTeleport={(position: THREE.Vector3) => {
      if (player) {
        player.position.copy(position);
        onTeleport(position);
      }
    }} />
  );
};

const WebXRPortfolio: React.FC = () => {
  const [activeExperience, setActiveExperience] = useState<ExperienceType>(null);
  
  return (
    <div className="webxr-container">
      {/* VR/AR entry buttons */}
      <div className="xr-buttons">
        <VRButton className="vr-button" />
        <ARButton className="ar-button" />
      </div>
      
      <Canvas className="webxr-canvas">
        <XR>
          {/* XR interactions */}
          <Hands />
          <Controllers />
          <XRNavigator onTeleport={(position: THREE.Vector3) => {
            // We can log teleport events or implement additional behaviors here
            console.log(`Teleported to ${position.x}, ${position.y}, ${position.z}`);
          }} />
          
          {/* Portfolio environment */}
          <PortfolioEnvironment />
          <Sky sunPosition={[0, 1, 0]} />
          <Stars radius={100} depth={50} count={5000} factor={4} />
          <Environment preset="sunset" />
          
          {/* Welcome Text */}
          <DreiBoard position={[0, 2, -5]}>
            <Text fontSize={0.2} color="#ffffff" anchorX="center" anchorY="middle">
              Welcome to my WebXR Tech Portfolio
            </Text>
            <Text position={[0, -0.3, 0]} fontSize={0.1} color="#ccccff" anchorX="center" anchorY="middle">
              Interact with the exhibits using your controllers
            </Text>
          </DreiBoard>
          
          {/* Portfolio visualizations */}
          <group position={[-4, 0, 0]}>
            <RayGrab>
              <Interactive onSelect={() => setActiveExperience('llama')}>
                <LlamaCoreXR scale={0.5} position={[-4, 1.5, -3]} />
                <Text position={[-4, 0.5, -3]} fontSize={0.15} anchorX="center">
                  LlamaCore Visualization
                </Text>
              </Interactive>
            </RayGrab>
          </group>
          
          <group position={[-2, 0, 0]}>
            <RayGrab>
              <Interactive onSelect={() => setActiveExperience('particles')}>
                <ParticleSystemXR scale={0.5} position={[0, 1.5, -3]} />
                <Text position={[0, 0.5, -3]} fontSize={0.15} anchorX="center">
                  Particle System
                </Text>
              </Interactive>
            </RayGrab>
          </group>
          
          <group position={[2, 0, 0]}>
            <RayGrab>
              <Interactive onSelect={() => setActiveExperience('network')}>
                <NetworkVisualizationXR scale={0.5} position={[4, 1.5, -3]} />
                <Text position={[4, 0.5, -3]} fontSize={0.15} anchorX="center">
                  Network Visualization
                </Text>
              </Interactive>
            </RayGrab>
          </group>
          
          <group position={[-4, 0, -6]}>
            <RayGrab>
              <Interactive onSelect={() => setActiveExperience('terrain')}>
                <TerrainMappingXR scale={0.5} position={[-4, 1.5, -6]} />
                <Text position={[-4, 0.5, -6]} fontSize={0.15} anchorX="center">
                  Terrain Mapping
                </Text>
              </Interactive>
            </RayGrab>
          </group>
          
          <group position={[4, 0, -6]}>
            <RayGrab>
              <Interactive onSelect={() => setActiveExperience('neural')}>
                <NeuralNetworkXR scale={0.5} position={[4, 1.5, -6]} />
                <Text position={[4, 0.5, -6]} fontSize={0.15} anchorX="center">
                  Neural Network
                </Text>
              </Interactive>
            </RayGrab>
          </group>
          
          {/* Detail view for active experience */}
          {activeExperience && (
            <group position={[0, 1.5, -3]}>
              <Interactive onSelect={() => setActiveExperience(null)}>
                <mesh position={[0, 2, 0]}>
                  <boxGeometry args={[0.3, 0.3, 0.1]} />
                  <meshStandardMaterial color="red" />
                </mesh>
                <Text position={[0, 2, 0.1]} fontSize={0.1} anchorX="center" anchorY="middle">
                  Close
                </Text>
              </Interactive>
              
              {activeExperience === 'llama' && <LlamaCoreXR scale={1} position={[0, 1.5, 0]} />}
              {activeExperience === 'particles' && <ParticleSystemXR scale={1} position={[0, 1.5, 0]} />}
              {activeExperience === 'network' && <NetworkVisualizationXR scale={1} position={[0, 1.5, 0]} />}
              {activeExperience === 'terrain' && <TerrainMappingXR scale={1} position={[0, 1.5, 0]} />}
              {activeExperience === 'neural' && <NeuralNetworkXR scale={1} position={[0, 1.5, 0]} />}
            </group>
          )}
        </XR>
      </Canvas>
    </div>
  );
};

export default WebXRPortfolio;import React, { useState, useRef, useEffect } from 'react';
import { Canvas } from '@react-three/fiber';
import { 
  PresentationControls, 
  Environment, 
  Float, 
  Sky, 
  Stars,
  PerspectiveCamera
} from '@react-three/drei';
import { motion } from 'framer-motion';

// Import visualization components
import { LlamaCoreXR } from '../components/visualizations/LlamaCoreXR';
import { ParticleSystemXR } from '../components/visualizations/ParticleSystemXR';
import { NetworkVisualizationXR } from '../components/visualizations/NetworkVisualizationXR';
import { TerrainMappingXR } from '../components/visualizations/TerrainMappingXR';
import { NeuralNetworkXR } from '../components/visualizations/NeuralNetworkXR';
import { Section } from '../types';

const sections: Section[] = [
  { id: 'intro', title: 'Welcome to WebXR Tech Portfolio' },
  { id: 'llama', title: 'LlamaCore Visualization' },
  { id: 'particles', title: 'Particle System' },
  { id: 'network', title: 'Network Visualization' },
  { id: 'terrain', title: 'Terrain Mapping' },
  { id: 'neural', title: 'Neural Network' },
  { id: 'webxr', title: 'Try in WebXR' }
];

const DesktopPortfolio: React.FC = () => {
  const [activeSection, setActiveSection] = useState<number>(0);
  const [canvasVisible, setCanvasVisible] = useState<boolean>(false);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Show canvas after a short delay for smoother loading
  useEffect(() => {
    const timer = setTimeout(() => {
      setCanvasVisible(true);
    }, 100);
    return () => clearTimeout(timer);
  }, []);
  
  // Handle section navigation
  const navigateToSection = (index: number): void => {
    setActiveSection(index);
  };
  
  return (
    <div className="desktop-portfolio" ref={containerRef}>
      {/* Navigation sidebar */}
      <div className="portfolio-nav">
        {sections.map((section, index) => (
          <motion.button
            key={section.id}
            className={`nav-button ${activeSection === index ? 'active' : ''}`}
            onClick={() => navigateToSection(index)}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            {section.title}
          </motion.button>
        ))}
      </div>
      
      {/* Main content */}
      <motion.div 
        className="portfolio-content"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.5 }}
      >
        {/* Section specific content */}
        <div className="section-content">
          {activeSection === 0 && (
            <motion.div 
              className="intro-section"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <h1>WebXR Tech Portfolio</h1>
              <p>Explore interactive 3D visualizations powered by Three.js and WebXR</p>
              <p>Navigate through the sections to see different technical demos and visualizations</p>
              
              <div className="tech-stack">
                <h3>Technologies:</h3>
                <ul>
                  <li>Three.js</li>
                  <li>React Three Fiber</li>
                  <li>WebXR</li>
                  <li>React</li>
                </ul>
              </div>
              
              <div className="instructions">
                <h3>Instructions:</h3>
                <p>Click and drag to rotate models</p>
                <p>Scroll to zoom in/out</p>
                <p>Click on the WebXR section to experience in VR/AR (if supported by your device)</p>
              </div>
            </motion.div>
          )}
          
          {activeSection === 1 && (
            <motion.div 
              className="section-info"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <h2>LlamaCore Visualization</h2>
              <p>This interactive 3D visualization demonstrates real-time data rendering with dynamic color changes based on system health metrics.</p>
              <p>The model changes color from green to red as the health decreases, and becomes more transparent.</p>
              <p>Particle effects surround the model for additional visual interest.</p>
            </motion.div>
          )}
          
          {activeSection === 2 && (
            <motion.div 
              className="section-info"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <h2>Particle System</h2>
              <p>Advanced particle systems with instance rendering demonstrate high-performance rendering techniques.</p>
              <p>Thousands of particles are animated in real-time with unique movement patterns and colors.</p>
              <p>The system is optimized for both desktop and VR with dynamic level-of-detail adjustments.</p>
            </motion.div>
          )}
          
          {activeSection === 3 && (
            <motion.div 
              className="section-info"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <h2>Network Visualization</h2>
              <p>Interactive network visualization demonstrating node-based data representation.</p>
              <p>Nodes and connections are generated procedurally and can be interacted with.</p>
              <p>The visualization supports real-time data mapping and can be used for displaying complex systems or API relationships.</p>
            </motion.div>
          )}
          
          {activeSection === 4 && (
            <motion.div 
              className="section-info"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <h2>Terrain Mapping</h2>
              <p>Real-time terrain visualization with radar-like scanning effect.</p>
              <p>Procedurally generated terrain can represent different environment types: mountains, canyons, coastal areas, and urban landscapes.</p>
              <p>In VR mode, the terrain can be directly manipulated with controllers.</p>
            </motion.div>
          )}
          
          {activeSection === 5 && (
            <motion.div 
              className="section-info"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <h2>Neural Network</h2>
              <p>Interactive neural network visualization with dynamic signal propagation.</p>
              <p>Click on neurons to see activation patterns flow through the network.</p>
              <p>Visual representation of machine learning processes with customizable layers and node counts.</p>
            </motion.div>
          )}
          
          {activeSection === 6 && (
            <motion.div 
              className="webxr-info"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <h2>Experience in WebXR</h2>
              <p>All of these visualizations are enhanced in WebXR mode, allowing you to:</p>
              <ul>
                <li>Walk around and explore the 3D models from any angle</li>
                <li>Interact using VR controllers or AR touch</li>
                <li>Experience immersive visualizations with depth and scale</li>
                <li>Manipulate objects directly in 3D space</li>
              </ul>
              
              <div className="webxr-cta">
                <a href="#/xr" className="webxr-button">Launch in WebXR</a>
                <span className="or">or</span>
                <a href="#/xr?ar=1" className="webxr-button ar">Launch in AR</a>
              </div>
              
              <p className="device-note">Note: WebXR requires a compatible device and browser</p>
            </motion.div>
          )}
        </div>
        
        {/* 3D Canvas - conditionally rendered based on active section */}
        {canvasVisible && activeSection > 0 && activeSection < 6 && (
          <div className="canvas-container">
            <Canvas dpr={[1, 2]}>
              <PerspectiveCamera makeDefault position={[0, 0, 10]} fov={50} />
              
              <PresentationControls
                global
                rotation={[0, 0, 0]}
                polar={[-Math.PI / 4, Math.PI / 4]}
                azimuth={[-Math.PI / 4, Math.PI / 4]}
                config={{ mass: 2, tension: 400 }}
                snap={{ mass: 4, tension: 400 }}
              >
                <Float rotationIntensity={0.4} floatIntensity={0.4}>
                  {/* Different visualization based on active section */}
                  {activeSection === 1 && <LlamaCoreXR position={[0, 0, 0]} scale={1.5} />}
                  {activeSection === 2 && <ParticleSystemXR position={[0, 0, 0]} scale={0.3} />}
                  {activeSection === 3 && <NetworkVisualizationXR position={[0, 0, 0]} scale={1} />}
                  {activeSection === 4 && <TerrainMappingXR position={[0, 0, 0]} scale={0.5} />}
                  {activeSection === 5 && <NeuralNetworkXR position={[0, 0, 0]} scale={1} />}
                </Float>
              </PresentationControls>
              
              {/* Environment lighting */}
              <Environment preset="sunset" />
              <ambientLight intensity={0.5} />
              <pointLight position={[10, 10, 10]} intensity={0.5} />
              
              {/* Background elements */}
              <Sky sunPosition={[0, 1, 0]} />
              <Stars radius={100} depth={50} count={1000} factor={4} />
            </Canvas>
          </div>
        )}
      </motion.div>
    </div>
  );
};

export default DesktopPortfolio;
// src/__tests__/integration/ControllerInput.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, act } from '@testing-library/react';
import { XboxControllerInput } from '../../components/XboxControllerInput';

describe('XboxControllerInput Integration', () => {
  beforeEach(() => {
    // Mock gamepad API with an Xbox controller
    const mockXboxController = {
      id: 'Xbox Controller (Vendor: 045e Product: 02fd)',
      mapping: 'standard',
      axes: [0, 0, 0, 0],
      buttons: Array(16).fill({ pressed: false, value: 0 }),
      connected: true,
      index: 0
    };
    
    global.navigator.getGamepads = vi.fn(() => [mockXboxController]);
    
    // Mock requestAnimationFrame
    global.requestAnimationFrame = vi.fn(callback => {
      callback(0);
      return 0;
    });
  });
  
  it('calls onMove when stick is moved beyond deadzone', () => {
    const mockOnMove = vi.fn();
    const mockOnSelect = vi.fn();
    
    render(<XboxControllerInput onMove={mockOnMove} onSelect={mockOnSelect} />);
    
    // Simulate left stick movement
    const mockControllerWithMovement = {
      id: 'Xbox Controller (Vendor: 045e Product: 02fd)',
      mapping: 'standard',
      axes: [0.5, -0.3, 0, 0], // x=0.5, y=-0.3 for left stick
      buttons: Array(16).fill({ pressed: false, value: 0 }),
      connected: true,
      index: 0
    };
    
    global.navigator.getGamepads = vi.fn(() => [mockControllerWithMovement]);
    
    // Trigger animation frame to process movement
    act(() => {
      global.requestAnimationFrame.mock.calls[0][0](0);
    });
    
    // Verify onMove was called with correct values
    expect(mockOnMove).toHaveBeenCalledWith(expect.objectContaining({
      x: expect.any(Number),
      z: expect.any(Number)
    }));
    
    // Verify x value is positive (right) and z is positive (backward)
    const moveCall = mockOnMove.mock.calls[0][0];
    expect(moveCall.x).toBeGreaterThan(0);
    expect(moveCall.z).toBeLessThan(0);
  });
  
  it('calls onSelect when A button is pressed', () => {
    const mockOnMove = vi.fn();
    const mockOnSelect = vi.fn();
    
    render(<XboxControllerInput onMove={mockOnMove} onSelect={mockOnSelect} />);
    
    // Simulate A button press
    const mockControllerWithButtonPress = {
      id: 'Xbox Controller (Vendor: 045e Product: 02fd)',
      mapping: 'standard',
      axes: [0, 0, 0, 0],
      buttons: Array(16).fill({ pressed: false, value: 0 }),
      connected: true,
      index: 0
    };
    
    // Set A button to pressed (index 0)
    mockControllerWithButtonPress.buttons[0] = { pressed: true, value: 1 };
    
    global.navigator.getGamepads = vi.fn(() => [mockControllerWithButtonPress]);
    
    // Trigger animation frame to process button press
    act(() => {
      global.requestAnimationFrame.mock.calls[0][0](0);
    });
    
    // Verify onSelect was called
    expect(mockOnSelect).toHaveBeenCalled();
  });
});

// src/__tests__/integration/Portal.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, fireEvent, screen } from '@testing-library/react';
import { Portal } from '../../components/Portal';
import * as THREE from 'three';

// Mock Three.js texture
vi.mock('three', async () => {
  const actual = await vi.importActual('three');
  return {
    ...actual,
    TextureLoader: vi.fn().mockImplementation(() => ({
      load: vi.fn().mockReturnValue({})
    }))
  };
});

describe('Portal Integration', () => {
  it('renders with title and triggers onClick when selected', () => {
    const mockOnClick = vi.fn();
    const testTitle = "Test Portal";
    const mockThumbnail = new THREE.Texture();
    
    render(
      <Portal 
        position={[0, 0, 0]} 
        rotation={[0, 0, 0]} 
        title={testTitle}
        thumbnail={mockThumbnail}
        onClick={mockOnClick}
      />
    );
    
    // Find text element with the title
    expect(screen.getByText(testTitle)).toBeInTheDocument();
    
    // Simulate click/selection
    fireEvent.click(screen.getByText(testTitle));
    
    // Verify onClick callback was called
    expect(mockOnClick).toHaveBeenCalled();
  });
  
  it('changes appearance when hovered', async () => {
    const mockOnClick = vi.fn();
    const mockThumbnail = new THREE.Texture();
    
    const { container } = render(
      <Portal 
        position={[0, 0, 0]} 
        rotation={[0, 0, 0]} 
        title="Test Portal"
        thumbnail={mockThumbnail}
        onClick={mockOnClick}
      />
    );
    
    // Note: Testing hover state in Three.js components is challenging
    // in a standard testing environment, as it requires simulating
    // Three.js-specific events. This is more of a placeholder for
    // how you might approach it.
    
    // This would be better tested in an e2e test with a real renderer
    expect(container).toBeTruthy();
  });
});

// src/__tests__/integration/KeyboardMouseControls.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, fireEvent } from '@testing-library/react';
import { KeyboardMouseControls } from '../../components/KeyboardMouseControls';

describe('KeyboardMouseControls Integration', () => {
  beforeEach(() => {
    // Mock useThree
    vi.mock('@react-three/fiber', () => ({
      useThree: () => ({
        camera: {
          position: { x: 0, y: 0, z: 0 }
        }
      }),
      useFrame: vi.fn(callback => callback())
    }));
    
    // Mock PointerLockControls
    vi.mock('@react-three/drei', () => ({
      PointerLockControls: vi.fn().mockImplementation(() => ({
        isLocked: true,
        moveRight: vi.fn(),
        moveForward: vi.fn(),
        lock: vi.fn(),
        unlock: vi.fn()
      }))
    }));
  });
  
  it('responds to WASD key presses', () => {
    const { container } = render(<KeyboardMouseControls enabled={true} />);
    
    // Simulate W key press
    fireEvent.keyDown(window, { code: 'KeyW' });
    // Simulate A key press
    fireEvent.keyDown(window, { code: 'KeyA' });
    
    // Verify component renders
    expect(container).toBeTruthy();
    
    // Simulate key release
    fireEvent.keyUp(window, { code: 'KeyW' });
    fireEvent.keyUp(window, { code: 'KeyA' });
    
    // Note: Full testing would require checking that the
    // actual movement occurred, which is challenging without
    // a full Three.js environment
  });
  
  it('does not respond to key presses when disabled', () => {
    const { container } = render(<KeyboardMouseControls enabled={false} />);
    
    // Simulate W key press
    fireEvent.keyDown(window, { code: 'KeyW' });
    
    // We can't easily verify the internal state didn't change
    // but we can at least verify the component renders
    expect(container).toBeTruthy();
  });
});
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './styles/main.css';

// WebGL context loss detection
const setupWebGLDetection = () => {
  window.addEventListener('webglcontextlost', (event) => {
    // Prevent the default behavior
    event.preventDefault();
    console.warn('WebGL context lost. This may impact 3D functionality.');
  });

  window.addEventListener('webglcontextrestored', () => {
    console.log('WebGL context restored.');
  });
};

// Setup error handlers
const setupErrorHandlers = () => {
  window.addEventListener('error', (event) => {
    console.error('Global error caught:', event.message);
    // Don't prevent default so errors still show in console
  });

  window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    // Don't prevent default so errors still show in console
  });
};

// Initialize app
const initApp = () => {
  try {
    // Setup event handlers
    setupWebGLDetection();
    setupErrorHandlers();
    
    // Mount React app
    const container = document.getElementById('root');
    if (!container) throw new Error('Failed to find the root element');

    const root = createRoot(container);
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  } catch (err) {
    console.error('Failed to initialize app:', err);
    
    // Show fallback UI
    const rootElement = document.getElementById('root');
    if (rootElement) {
      rootElement.innerHTML = `
        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; padding: 20px; text-align: center; background-color: #121220; color: white;">
          <h2>Application Error</h2>
          <p>Sorry, the application could not be loaded.</p>
          <p style="color: #ff6b6b;">Error: ${err.message || 'Unknown error'}</p>
          <button onclick="window.location.reload()" style="padding: 8px 16px; margin-top: 20px; background-color: #4a4acf; color: white; border: none; border-radius: 4px; cursor: pointer;">
            Reload Application
          </button>
        </div>
      `;
    }
  }
};

// Start the application
initApp();import React, { useState, Suspense } from 'react';
import { HashRouter as Router, Routes, Route } from 'react-router-dom';
import Navigation from './components/Navigation';
import DesktopPortfolio from './pages/DesktopPortfolio';
import WebXRPortfolio from './pages/WebXRPortfolio';
import Loader from './components/Loader';
import WebGLContextHandler from './components/utils/WebGLContextHandler';

// WebXR type declarations
declare global {
  interface Navigator {
    xr?: XRSystem;
  }

  interface XRSystem {
    isSessionSupported(mode: string): Promise<boolean>;
    requestSession(mode: string, options?: XRSessionInit): Promise<XRSession>;
  }

  interface XRSession {
    end(): Promise<void>;
  }

  interface XRSessionInit {
    optionalFeatures?: string[];
    requiredFeatures?: string[];
  }
}

const App: React.FC = () => {
  const [webXRSupported, setWebXRSupported] = useState<boolean | null>(null);

  // Check WebXR support on mount
  React.useEffect(() => {
    const checkWebXRSupport = async (): Promise<void> => {
      if (navigator.xr) {
        try {
          const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
          const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
          setWebXRSupported(vrSupported || arSupported);
        } catch (error) {
          console.warn('WebXR support check failed:', error);
          setWebXRSupported(false);
        }
      } else {
        setWebXRSupported(false);
      }
    };

    checkWebXRSupport();
  }, []);

  // Show loading state while checking WebXR support
  if (webXRSupported === null) {
    return <Loader message="Checking device capabilities..." />;
  }

  return (
    <WebGLContextHandler>
      <Router
        future={{
          v7_startTransition: true,
          v7_relativeSplatPath: true
        }}
      >
        <div className="app">
          <Navigation webXRSupported={webXRSupported} />
          <Suspense fallback={<Loader />}>
            <Routes>
              <Route path="/" element={<DesktopPortfolio />} />
              {webXRSupported && (
                <Route path="/xr" element={<WebXRPortfolio />} />
              )}
              <Route path="*" element={<DesktopPortfolio />} />
            </Routes>
          </Suspense>
        </div>
      </Router>
    </WebGLContextHandler>
  );
};

export default App;
import * as React from 'react'
import * as THREE from 'three'
import { useFrame, Object3DNode, extend, createPortal } from '@react-three/fiber'
import { useXR } from './XR'
import { XRController } from './XRController'
import { XRControllerModelFactory } from './XRControllerModelFactory'
import { XRControllerModel } from './XRControllerModel'
import { useCallbackRef } from './utils'

export interface RayProps extends Partial<JSX.IntrinsicElements['object3D']> {
  /** The XRController to attach the ray to */
  target: XRController
  /** Whether to hide the ray on controller blur. Default is `false` */
  hideOnBlur?: boolean
}

export const Ray = React.forwardRef<THREE.Line, RayProps>(function Ray({ target, hideOnBlur = false, ...props }, forwardedRef) {
  const hoverState = useXR((state) => state.hoverState)
  const ray = React.useRef<THREE.Line>(null!)
  const rayGeometry = React.useMemo(
    () => new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]),
    []
  )
  React.useImperativeHandle(forwardedRef, () => ray.current)

  // Show ray line when hovering objects
  useFrame(() => {
    if (!target.inputSource) {
      return
    }

    let rayLength = 1

    const intersection: THREE.Intersection = hoverState[target.inputSource.handedness].values().next().value
    if (intersection && target.inputSource.handedness !== 'none') {
      rayLength = intersection.distance
      if (hideOnBlur) ray.current.visible = false
    } else if (hideOnBlur) {
      ray.current.visible = true
    }

    // Tiny offset to clip ray on AR devices
    // that don't have handedness set to 'none'
    const offset = -0.01
    ray.current.scale.z = rayLength + offset
  })

  // @ts-ignore TS assumes that JS is for the web, and overrides line w/SVG props
  return <line ref={ray} geometry={rayGeometry} material-opacity={0.8} material-transparent={true} {...props} />
})

const modelFactory = new XRControllerModelFactory()

declare global {
  namespace JSX {
    interface IntrinsicElements {
      xRControllerModel: Object3DNode<XRControllerModel, typeof XRControllerModel>
    }
  }
}

export interface ControllersProps {
  /** Optional material props to pass to controllers' ray indicators */
  rayMaterial?: JSX.IntrinsicElements['meshBasicMaterial']
  /** Whether to hide controllers' rays on blur. Default is `false` */
  hideRaysOnBlur?: boolean
  /**
   * Optional environment map to apply to controller models.
   * Useful for make controllers look more realistic
   * if you don't want to apply an env map globally on a scene
   */
  envMap?: THREE.Texture
  /**
   * Optional environment map intensity to apply to controller models.
   * Useful for tweaking the env map intensity if they look too bright or dark
   */
  envMapIntensity?: number
}

const ControllerModel = ({
  target,
  envMap,
  envMapIntensity
}: {
  target: XRController
  envMap?: THREE.Texture
  envMapIntensity?: number
}) => {
  const xrControllerModelRef = React.useRef<XRControllerModel | null>(null)
  const setEnvironmentMapRef = useCallbackRef((xrControllerModel: XRControllerModel) => {
    if (envMap == null) return
    xrControllerModel.setEnvironmentMap(envMap)
  })
  const clearEnvironmentMapRef = useCallbackRef((xrControllerModel: XRControllerModel) => xrControllerModel.setEnvironmentMap(null))

  const setEnvironmentMapIntensityRef = useCallbackRef((xrControllerModel: XRControllerModel) => {
    if (envMapIntensity == null) return
    xrControllerModel.setEnvironmentMapIntensity(envMapIntensity)
  })

  const handleControllerModel = React.useCallback(
    (xrControllerModel: XRControllerModel | null) => {
      xrControllerModelRef.current = xrControllerModel
      if (xrControllerModel) {
        target.xrControllerModel = xrControllerModel
        if (target.inputSource?.hand) {
          return
        }

        setEnvironmentMapRef.current(xrControllerModel)
        setEnvironmentMapIntensityRef.current(xrControllerModel)
        if (target.inputSource) {
          modelFactory.initializeControllerModel(xrControllerModel, target.inputSource)
        } else {
          console.warn('no input source on XRController when handleControllerModel')
        }
      } else {
        if (target.inputSource?.hand) {
          return
        }
        target.xrControllerModel?.disconnect()
        target.xrControllerModel = null
      }
    },
    [target, setEnvironmentMapIntensityRef, setEnvironmentMapRef]
  )

  React.useLayoutEffect(() => {
    if (xrControllerModelRef.current) {
      if (envMap) {
        setEnvironmentMapRef.current(xrControllerModelRef.current)
      } else {
        clearEnvironmentMapRef.current(xrControllerModelRef.current)
      }
    }
  }, [envMap, setEnvironmentMapRef, clearEnvironmentMapRef])

  React.useLayoutEffect(() => {
    if (xrControllerModelRef.current) {
      setEnvironmentMapIntensityRef.current(xrControllerModelRef.current)
    }
  }, [envMapIntensity, setEnvironmentMapIntensityRef])

  return <xRControllerModel ref={handleControllerModel} />
}

export function Controllers({ rayMaterial = {}, hideRaysOnBlur = false, envMap, envMapIntensity }: ControllersProps) {
  const controllers = useXR((state) => state.controllers)
  const isHandTracking = useXR((state) => state.isHandTracking)
  const rayMaterialProps = React.useMemo(
    () =>
      Object.entries(rayMaterial).reduce(
        (acc, [key, value]) => ({
          ...acc,
          [`material-${key}`]: value
        }),
        {}
      ),
    [JSON.stringify(rayMaterial)] // eslint-disable-line react-hooks/exhaustive-deps
  )
  React.useMemo(() => extend({ XRControllerModel }), [])

  return (
    <>
      {controllers.map((target, i) => (
        <React.Fragment key={i}>
          {createPortal(<ControllerModel target={target} envMap={envMap} envMapIntensity={envMapIntensity} />, target.grip)}
          {createPortal(
            <Ray visible={!isHandTracking} hideOnBlur={hideRaysOnBlur} target={target} {...rayMaterialProps} />,
            target.controller
          )}
        </React.Fragment>
      ))}
    </>
  )
}
import { describe, it, expect, vi } from 'vitest'
import { render } from './testUtils/testUtilsThree'
import * as React from 'react'
import { createStoreMock, createStoreProvider } from './mocks/storeMock'
import { InteractionManager, Interactive } from './Interactions'
import { XRControllerMock } from './mocks/XRControllerMock'
import { act } from '@react-three/test-renderer'
import { XRInputSourceMock } from './mocks/XRInputSourceMock'
import { Intersection } from '@react-three/fiber'
import { Vector3 } from 'three'

describe('Interactions', () => {
  it('should call onSelect when select event is dispatched', async () => {
    const store = createStoreMock()
    const xrControllerMock = new XRControllerMock(0)
    const xrInputSourceMock = new XRInputSourceMock({ handedness: 'right' })
    xrControllerMock.inputSource = xrInputSourceMock
    const rightHoverState = new Map()
    store.setState({
      controllers: [xrControllerMock],
      hoverState: {
        none: new Map(),
        left: new Map(),
        right: rightHoverState
      }
    })

    const selectSpy = vi.fn()
    const { renderer } = await render(
      <InteractionManager>
        <Interactive onSelect={selectSpy}>
          <mesh position={[0, 0, -1]}>
            <planeGeometry args={[1, 1]} />
          </mesh>
        </Interactive>
      </InteractionManager>,
      { wrapper: createStoreProvider(store) }
    )

    const mesh = renderer.scene.findByType('Mesh').instance
    const interactiveGroup = renderer.scene.findByType('Group').instance
    expect(mesh).toBeDefined()
    expect(interactiveGroup).toBeDefined()
    const intersection: Intersection = {
      eventObject: mesh,
      distance: 1,
      point: new Vector3(0, 0, 0),
      object: mesh
    }

    rightHoverState.set(mesh, intersection)
    rightHoverState.set(interactiveGroup, intersection)

    await act(async () => {
      xrControllerMock.controller.dispatchEvent({ type: 'select', data: {} })
    })

    expect(selectSpy).toBeCalled()
  })
})
import * as THREE from 'three'
import * as React from 'react'
import { useFrame, useThree } from '@react-three/fiber'
import { Interactive, type XRInteractionEvent } from './Interactions'

const _q = /* @__PURE__ */ new THREE.Quaternion()

/**
 * Teleport callback, accepting a world-space target position to teleport to.
 */
export type TeleportCallback = (target: THREE.Vector3 | THREE.Vector3Tuple) => void

/**
 * Returns a {@link TeleportCallback} to teleport the player to a position.
 */
export function useTeleportation(): TeleportCallback {
  const frame = React.useRef<XRFrame>()
  const baseReferenceSpace = React.useRef<XRReferenceSpace | null>(null)
  const teleportReferenceSpace = React.useRef<XRReferenceSpace | null>(null)

  useFrame((state, _, xrFrame) => {
    frame.current = xrFrame

    const referenceSpace = state.gl.xr.getReferenceSpace()
    baseReferenceSpace.current ??= referenceSpace

    const teleportOffset = teleportReferenceSpace.current
    if (teleportOffset && referenceSpace !== teleportOffset) {
      state.gl.xr.setReferenceSpace(teleportOffset)
    }
  })

  return React.useCallback((target) => {
    const base = baseReferenceSpace.current
    if (base) {
      const [x, y, z] = Array.from(target as THREE.Vector3Tuple)
      const offsetFromBase = { x: -x, y: -y, z: -z }

      const pose = frame.current?.getViewerPose(base)
      if (pose) {
        offsetFromBase.x += pose.transform.position.x
        offsetFromBase.z += pose.transform.position.z
      }

      const teleportOffset = new XRRigidTransform(offsetFromBase, _q)
      teleportReferenceSpace.current = base.getOffsetReferenceSpace(teleportOffset)
    }
  }, [])
}

export interface TeleportationPlaneProps extends Partial<JSX.IntrinsicElements['group']> {
  /** Whether to allow teleportation from left controller. Default is `false` */
  leftHand?: boolean
  /** Whether to allow teleportation from right controller. Default is `false` */
  rightHand?: boolean
  /** The maximum distance from the camera to the teleportation point. Default is `10` */
  maxDistance?: number
  /** The radial size of the teleportation marker. Default is `0.25` */
  size?: number
}

/**
 * Creates a teleportation plane with a marker that will teleport on interaction.
 */
export const TeleportationPlane = React.forwardRef<THREE.Group, TeleportationPlaneProps>(function TeleportationPlane(
  { leftHand = false, rightHand = false, maxDistance = 10, size = 0.25, ...props },
  ref
) {
  const teleport = useTeleportation()
  const marker = React.useRef<THREE.Mesh>(null!)
  const intersection = React.useRef<THREE.Vector3>()
  const camera = useThree((state) => state.camera)

  const isInteractive = React.useCallback(
    (e: XRInteractionEvent): boolean => {
      const handedness = e.target.inputSource?.handedness
      return !!((handedness !== 'left' || leftHand) && (handedness !== 'right' || rightHand))
    },
    [leftHand, rightHand]
  )

  return (
    <group ref={ref} {...props}>
      <mesh ref={marker} visible={false} rotation-x={-Math.PI / 2}>
        <circleGeometry args={[size, 32]} />
        <meshBasicMaterial color="white" />
      </mesh>
      <Interactive
        onMove={(e) => {
          if (!isInteractive(e) || !e.intersection) return

          const distanceFromCamera = e.intersection.point.distanceTo(camera.position)
          marker.current.visible = distanceFromCamera <= maxDistance
          marker.current.scale.setScalar(1)

          intersection.current = e.intersection.point
          marker.current.position.copy(intersection.current)
        }}
        onHover={(e) => {
          if (!isInteractive(e) || !e.intersection) return

          const distanceFromCamera = e.intersection.point.distanceTo(camera.position)
          marker.current.visible = distanceFromCamera <= maxDistance
          marker.current.scale.setScalar(1)
        }}
        onBlur={(e) => {
          if (!isInteractive(e)) return
          marker.current.visible = false
        }}
        onSelectStart={(e) => {
          if (!isInteractive(e) || !e.intersection) return

          const distanceFromCamera = e.intersection.point.distanceTo(camera.position)
          marker.current.visible = distanceFromCamera <= maxDistance
          marker.current.scale.setScalar(1.1)
        }}
        onSelectEnd={(e) => {
          if (!isInteractive(e) || !intersection.current) return

          marker.current.visible = true
          marker.current.scale.setScalar(1)

          const distanceFromCamera = intersection.current.distanceTo(camera.position)
          if (distanceFromCamera <= maxDistance) {
            teleport(intersection.current)
          }
        }}
      >
        <mesh rotation-x={-Math.PI / 2} visible={false} scale={1000}>
          <planeGeometry />
        </mesh>
      </Interactive>
    </group>
  )
})
import * as React from 'react'
import { Object3DNode, extend, createPortal } from '@react-three/fiber'
import { OculusHandModel } from './OculusHandModel'
import { useXR } from './XR'
import { useIsomorphicLayoutEffect } from './utils'

declare global {
  namespace JSX {
    interface IntrinsicElements {
      oculusHandModel: Object3DNode<OculusHandModel, typeof OculusHandModel>
    }
  }
}

export interface HandsProps {
  modelLeft?: string
  modelRight?: string
}
export function Hands({ modelLeft, modelRight }: HandsProps) {
  const controllers = useXR((state) => state.controllers)
  React.useMemo(() => extend({ OculusHandModel }), [])

  // Send fake connected event (no-op) so models start loading
  useIsomorphicLayoutEffect(() => {
    for (const target of controllers) {
      target.hand.dispatchEvent({ type: 'connected', data: target.inputSource, fake: true })
    }
  }, [controllers, modelLeft, modelRight])

  return <>{controllers.map(({ hand }) => createPortal(<oculusHandModel args={[hand, modelLeft, modelRight]} />, hand))}</>
}
import * as React from 'react'
import { describe, it, expect, vi } from 'vitest'
import { createStoreMock, createStoreProvider } from './mocks/storeMock'
import { render } from './testUtils/testUtilsThree'
import { Controllers } from './Controllers'
import { XRControllerMock } from './mocks/XRControllerMock'
import { XRControllerModel } from './XRControllerModel'
import { XRControllerModelFactoryMock } from './mocks/XRControllerModelFactoryMock'
import { XRInputSourceMock } from './mocks/XRInputSourceMock'
import { act } from '@react-three/test-renderer'
import { Texture } from 'three'

vi.mock('./XRControllerModelFactory', async () => {
  const { XRControllerModelFactoryMock } = await vi.importActual<typeof import('./mocks/XRControllerModelFactoryMock')>(
    './mocks/XRControllerModelFactoryMock'
  )
  return { XRControllerModelFactory: XRControllerModelFactoryMock }
})

describe('Controllers', () => {
  it('should not render anything if controllers in state are empty', async () => {
    const store = createStoreMock()
    const xrControllerMock = new XRControllerMock(0)
    store.setState({ controllers: [] })

    const { renderer } = await render(<Controllers />, { wrapper: createStoreProvider(store) })

    // We aren't rendering anything as a direct children, only in portals
    const graph = renderer.toGraph()
    expect(graph).toHaveLength(0)
    // Checking portals
    expect(xrControllerMock.grip.children).toHaveLength(0)
    expect(xrControllerMock.controller.children).toHaveLength(0)
  })

  it('should render one xr controller model and one ray given one controller in state', async () => {
    const store = createStoreMock()
    const xrControllerMock = new XRControllerMock(0)
    store.setState({ controllers: [xrControllerMock] })

    await render(<Controllers />, { wrapper: createStoreProvider(store) })

    // Checking portals
    expect(xrControllerMock.grip.children).toHaveLength(1)
    expect(xrControllerMock.grip.children[0]).toBeInstanceOf(XRControllerModel)
    expect(xrControllerMock.controller.children).toHaveLength(1)
    expect(xrControllerMock.controller.children[0].type).toBe('Line')
  })

  it('should render two xr controller models and two rays given one controller in state', async () => {
    const store = createStoreMock()
    const xrControllerMockLeft = new XRControllerMock(0)
    const xrControllerMockRight = new XRControllerMock(1)
    store.setState({ controllers: [xrControllerMockLeft, xrControllerMockRight] })

    await render(<Controllers />, { wrapper: createStoreProvider(store) })

    // Checking portals
    // left
    expect(xrControllerMockLeft.grip.children).toHaveLength(1)
    expect(xrControllerMockLeft.grip.children[0]).toBeInstanceOf(XRControllerModel)
    expect(xrControllerMockLeft.controller.children).toHaveLength(1)
    expect(xrControllerMockLeft.controller.children[0].type).toBe('Line')
    // right
    expect(xrControllerMockRight.grip.children).toHaveLength(1)
    expect(xrControllerMockRight.grip.children[0]).toBeInstanceOf(XRControllerModel)
    expect(xrControllerMockRight.controller.children).toHaveLength(1)
    expect(xrControllerMockRight.controller.children[0].type).toBe('Line')
  })

  it('should remove xr controller model when controller is removed from state', async () => {
    const store = createStoreMock()
    const xrControllerMock = new XRControllerMock(0)
    xrControllerMock.inputSource = new XRInputSourceMock()
    store.setState({ controllers: [xrControllerMock] })

    const { renderer } = await render(<Controllers />, { wrapper: createStoreProvider(store) })

    await act(async () => {
      store.setState({ controllers: [] })
    })

    // We aren't rendering anything as a direct children, only in portals
    const graph = renderer.toGraph()
    expect(graph).toHaveLength(0)
    // Checking portals
    expect(xrControllerMock.grip.children).toHaveLength(0)
    expect(xrControllerMock.controller.children).toHaveLength(0)
  })

  it('should handle xr controller model given one controller in state', async () => {
    const store = createStoreMock()
    const xrControllerMock = new XRControllerMock(0)
    xrControllerMock.inputSource = new XRInputSourceMock()
    store.setState({ controllers: [xrControllerMock] })

    await render(<Controllers />, { wrapper: createStoreProvider(store) })

    const xrControllerModelFactory = XRControllerModelFactoryMock.instance
    expect(xrControllerModelFactory).toBeDefined()
    expect(xrControllerMock.xrControllerModel).toBeInstanceOf(XRControllerModel)
    expect(xrControllerModelFactory?.initializeControllerModel).toBeCalled()
  })

  it('should handle xr controller model when controller is removed from state', async () => {
    const store = createStoreMock()
    const xrControllerMock = new XRControllerMock(0)
    xrControllerMock.inputSource = new XRInputSourceMock()
    store.setState({ controllers: [xrControllerMock] })

    await render(<Controllers />, { wrapper: createStoreProvider(store) })

    const xrControllerModel = xrControllerMock.xrControllerModel
    const disconnectSpy = vi.spyOn(xrControllerModel!, 'disconnect')

    await act(async () => {
      store.setState({ controllers: [] })
    })

    const xrControllerModelFactory = XRControllerModelFactoryMock.instance
    expect(xrControllerModelFactory).toBeDefined()
    expect(xrControllerMock.xrControllerModel).toBeNull()
    expect(disconnectSpy).toBeCalled()
  })

  it('should not reconnect when component is rerendered', async () => {
    const store = createStoreMock()
    const xrControllerMock = new XRControllerMock(0)
    xrControllerMock.inputSource = new XRInputSourceMock()
    store.setState({ controllers: [xrControllerMock] })

    const { rerender } = await render(<Controllers />, { wrapper: createStoreProvider(store) })

    const xrControllerModel = xrControllerMock.xrControllerModel
    const disconnectSpy = vi.spyOn(xrControllerModel!, 'disconnect')

    await rerender(<Controllers />)

    const xrControllerModelFactory = XRControllerModelFactoryMock.instance
    expect(xrControllerModelFactory).toBeDefined()
    expect(xrControllerMock.xrControllerModel).not.toBeNull()
    expect(disconnectSpy).not.toBeCalled()
    expect(xrControllerModelFactory?.initializeControllerModel).toBeCalledTimes(1)
  })

  describe('envMap', () => {
    it("should not set env map if it's not provided in props", async () => {
      const store = createStoreMock()
      const xrControllerMock = new XRControllerMock(0)
      store.setState({ controllers: [xrControllerMock] })

      await render(<Controllers />, { wrapper: createStoreProvider(store) })

      const xrControllerModel = xrControllerMock.xrControllerModel

      expect(xrControllerModel!.envMap).toBeNull()
      expect(xrControllerModel!.envMapIntensity).toBe(1)
    })

    it("should set env map if it's provided in props", async () => {
      const store = createStoreMock()
      const xrControllerMock = new XRControllerMock(0)
      store.setState({ controllers: [xrControllerMock] })
      const envMap = new Texture()

      await render(<Controllers envMap={envMap} />, { wrapper: createStoreProvider(store) })

      const xrControllerModel = xrControllerMock.xrControllerModel

      expect(xrControllerModel!.envMap).toBe(envMap)
      expect(xrControllerModel!.envMapIntensity).toBe(1)
    })

    it("should only set env map intensity if it's provided in props", async () => {
      const store = createStoreMock()
      const xrControllerMock = new XRControllerMock(0)
      store.setState({ controllers: [xrControllerMock] })

      await render(<Controllers envMapIntensity={0.5} />, { wrapper: createStoreProvider(store) })

      const xrControllerModel = xrControllerMock.xrControllerModel

      expect(xrControllerModel!.envMap).toBeNull()
      expect(xrControllerModel!.envMapIntensity).toBe(0.5)
    })

    it("should change env map intensity if it's provided in props then updated to a different value", async () => {
      const store = createStoreMock()
      const xrControllerMock = new XRControllerMock(0)
      store.setState({ controllers: [xrControllerMock] })

      const { rerender } = await render(<Controllers envMapIntensity={0.5} />, { wrapper: createStoreProvider(store) })
      const xrControllerModel = xrControllerMock.xrControllerModel
      await rerender(<Controllers envMapIntensity={0.6} />)

      expect(xrControllerModel!.envMap).toBeNull()
      expect(xrControllerModel!.envMapIntensity).toBe(0.6)
    })

    it("should remove env map if it's provided in props first, and then removed", async () => {
      const store = createStoreMock()
      const xrControllerMock = new XRControllerMock(0)
      store.setState({ controllers: [xrControllerMock] })
      const envMap = new Texture()

      const { rerender } = await render(<Controllers envMap={envMap} />, { wrapper: createStoreProvider(store) })
      const xrControllerModel = xrControllerMock.xrControllerModel
      await rerender(<Controllers />)

      expect(xrControllerModel!.envMap).toBeNull()
    })

    it("should change env map intensity if it's provided in props then updated to a different value but envMap stays the same", async () => {
      const store = createStoreMock()
      const xrControllerMock = new XRControllerMock(0)
      store.setState({ controllers: [xrControllerMock] })
      const envMap = new Texture()

      const { rerender } = await render(<Controllers envMap={envMap} envMapIntensity={0.5} />, { wrapper: createStoreProvider(store) })
      const xrControllerModel = xrControllerMock.xrControllerModel
      await rerender(<Controllers envMap={envMap} envMapIntensity={0.6} />)

      expect(xrControllerModel!.envMap).toBe(envMap)
      expect(xrControllerModel!.envMapIntensity).toBe(0.6)
    })
  })
})
import create, { StoreApi, UseBoundStore } from 'zustand'
import * as React from 'react'
import * as THREE from 'three'
import { XRContext, XRState } from '../context'
import { Group } from 'three'
import { XRInteractionHandler, XRInteractionType } from '@react-three/xr'

export const createStoreMock = () =>
  create<XRState>((set, get) => ({
    set,
    get,

    controllers: [],
    isPresenting: false,
    isHandTracking: false,
    player: new Group(),
    session: null,
    foveation: 0,
    referenceSpace: 'local-floor',

    hoverState: {
      left: new Map(),
      right: new Map(),
      none: new Map()
    },
    interactions: new Map(),
    hasInteraction(object: THREE.Object3D, eventType: XRInteractionType) {
      return !!get()
        .interactions.get(object)
        ?.[eventType].some((handlerRef) => handlerRef.current)
    },
    getInteraction(object: THREE.Object3D, eventType: XRInteractionType) {
      return get()
        .interactions.get(object)
        ?.[eventType].reduce((result, handlerRef) => {
          if (handlerRef.current) {
            result.push(handlerRef.current)
          }
          return result
        }, [] as XRInteractionHandler[])
    },
    addInteraction(object: THREE.Object3D, eventType: XRInteractionType, handlerRef: React.RefObject<XRInteractionHandler>) {
      const interactions = get().interactions
      if (!interactions.has(object)) {
        interactions.set(object, {
          onHover: [],
          onBlur: [],
          onSelect: [],
          onSelectEnd: [],
          onSelectStart: [],
          onSelectMissed: [],
          onSqueeze: [],
          onSqueezeEnd: [],
          onSqueezeStart: [],
          onSqueezeMissed: [],
          onMove: []
        })
      }

      const target = interactions.get(object)!
      target[eventType].push(handlerRef)
    },
    removeInteraction(object: THREE.Object3D, eventType: XRInteractionType, handlerRef: React.RefObject<XRInteractionHandler>) {
      const target = get().interactions.get(object)
      if (target) {
        const interactionIndex = target[eventType].indexOf(handlerRef)
        if (interactionIndex !== -1) target[eventType].splice(interactionIndex, 1)
      }
    }
  }))

export const createStoreProvider =
  (store: UseBoundStore<XRState, StoreApi<XRState>>) =>
  ({ children }: React.PropsWithChildren) =>
    <XRContext.Provider value={store} children={children} />
import { expect } from 'vitest'
import { act, create, ReactTestRenderer, ReactTestRendererJSON } from 'react-test-renderer'
import { createRef, useEffect } from 'react'
import * as React from 'react'

/**
 * Got this from vitest react example
 * @see https://vitest.dev/guide/#examples
 */
function toJson(component: ReactTestRenderer) {
  const result = component.toJSON()
  expect(result).toBeDefined()
  expect(result).not.toBeInstanceOf(Array)
  return result as ReactTestRendererJSON
}

/**
 * Hack to make async effects affect render
 * @see https://stackoverflow.com/a/70926194
 */
export async function render(
  element: React.ReactElement,
  {
    wrapper: WrapperComponent
  }: { wrapper?: React.FunctionComponent<React.PropsWithChildren> | React.ComponentClass<React.PropsWithChildren> } = {}
) {
  let root: ReactTestRenderer = null!

  const wrapUiIfNeeded = (innerElement: React.ReactElement) =>
    WrapperComponent ? React.createElement(WrapperComponent, null, innerElement) : innerElement

  await act(async () => {
    root = create(wrapUiIfNeeded(element))
  })

  function rerender(newElement = element) {
    root.update(wrapUiIfNeeded(newElement))
  }

  function unmount() {
    root.unmount()
  }

  return {
    toJson: () => toJson(root),
    rerender,
    unmount
  }
}

export async function renderHook<T>(
  hook: () => T,
  { wrapper }: { wrapper?: React.FunctionComponent<React.PropsWithChildren> | React.ComponentClass<React.PropsWithChildren> } = {}
) {
  const result = createRef<T | undefined>() as React.MutableRefObject<T | undefined>

  function TestComponent() {
    const pendingResult = hook()

    useEffect(() => {
      result.current = pendingResult
    })

    return null
  }

  const { rerender: baseRerender, unmount } = await render(<TestComponent />, { wrapper })

  function rerender() {
    return baseRerender(<TestComponent />)
  }

  return { result, rerender, unmount }
}
import { create } from '@react-three/test-renderer'
import * as React from 'react'

export async function render(
  element: React.ReactElement,
  {
    wrapper: WrapperComponent
  }: { wrapper?: React.FunctionComponent<React.PropsWithChildren> | React.ComponentClass<React.PropsWithChildren> } = {}
) {
  const wrapUiIfNeeded = (innerElement: React.ReactElement) =>
    WrapperComponent ? React.createElement(WrapperComponent, null, innerElement) : innerElement

  const renderer = await create(wrapUiIfNeeded(element))

  async function rerender(newElement = element) {
    await renderer.update(wrapUiIfNeeded(newElement))
  }

  async function unmount() {
    await renderer.unmount()
  }

  return {
    renderer,
    rerender,
    unmount
  }
}
import { describe, expect, it, vi } from 'vitest'
import { renderHook } from './testUtils/testUtilsDom'
import { useXREvent } from './XREvents'
import { createStoreMock, createStoreProvider } from './mocks/storeMock'
import { XRControllerMock } from './mocks/XRControllerMock'

describe('XREvents', () => {
  it('should not call callback if no events happened', async () => {
    const selectSpy = vi.fn()
    const store = createStoreMock()

    await renderHook(() => useXREvent('select', selectSpy), {
      wrapper: createStoreProvider(store)
    })

    expect(selectSpy).not.toBeCalled()
  })

  it('should call callback with custom data including native event and target when xr event is dispatched', async () => {
    const selectSpy = vi.fn()
    const store = createStoreMock()
    const xrControllerMock = new XRControllerMock(0)
    store.setState({
      controllers: [xrControllerMock]
    })

    await renderHook(() => useXREvent('select', selectSpy), {
      wrapper: createStoreProvider(store)
    })
    xrControllerMock.controller.dispatchEvent({ type: 'select' })

    expect(selectSpy).toBeCalledTimes(1)
    expect(selectSpy).toBeCalledWith(
      expect.objectContaining({
        nativeEvent: expect.objectContaining({ type: 'select' }),
        target: xrControllerMock
      })
    )
  })
})
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { XRButton } from './XR'
import * as React from 'react'
import { XRSystemMock } from './mocks/XRSystemMock'
import { render } from './testUtils/testUtilsDom'

describe('XR', () => {
  let xrSystemMock = new XRSystemMock()
  beforeEach(() => {
    location.href = 'https://example.com'
    navigator.xr = xrSystemMock
  })

  afterEach(() => {
    delete navigator.xr
    vi.restoreAllMocks()
  })

  it('should render unsupported button if navigator.xr is not present', async () => {
    delete navigator.xr
    const { toJson } = await render(<XRButton mode="VR" />)
    const tree = toJson()
    expect(tree).toMatchInlineSnapshot(`
      <button>
        VR unsupported
      </button>
    `)
  })

  it('should render unsupported button if navigator.xr is present but isSessionSupported returns false for vr', async () => {
    xrSystemMock.isSessionSupported.mockResolvedValueOnce(false)
    const { toJson } = await render(<XRButton mode="VR" />)
    const tree = toJson()
    expect(tree).toMatchInlineSnapshot(`
      <button>
        VR unsupported
      </button>
    `)
  })

  it('should render https needed button if navigator.xr is present but protocol is not https', async () => {
    location.href = 'http://example.com'
    xrSystemMock.isSessionSupported.mockResolvedValueOnce(false)
    const { toJson } = await render(<XRButton mode="VR" />)
    const tree = toJson()
    expect(tree).toMatchInlineSnapshot(`
      <button>
        HTTPS needed
      </button>
    `)
  })

  it('should render unsupported button if navigator.xr is present but isSessionSupported rejects with non discernable error', async () => {
    xrSystemMock.isSessionSupported.mockRejectedValueOnce(new DOMException('', ''))
    const { toJson } = await render(<XRButton mode="VR" />)
    const tree = toJson()
    expect(tree).toMatchInlineSnapshot(`
      <button>
        VR unsupported
      </button>
    `)
  })

  it('should render https needed button if navigator.xr is present but isSessionSupported rejects with SecurityError', async () => {
    xrSystemMock.isSessionSupported.mockRejectedValueOnce(new DOMException('', 'SecurityError'))
    const { toJson } = await render(<XRButton mode="VR" />)
    const tree = toJson()
    expect(tree).toMatchInlineSnapshot(`
      <button>
        VR blocked
      </button>
    `)
  })

  it('should render enter vr button if navigator.xr is present and isSessionSupported returns true for vr', async () => {
    xrSystemMock.isSessionSupported.mockResolvedValueOnce(true)
    const { toJson } = await render(<XRButton mode="VR" />)
    const tree = toJson()
    expect(tree).toMatchInlineSnapshot(`
      <button
        onClick={[Function]}
      >
        Enter VR
      </button>
    `)
  })

  it('should render enter ar button if navigator.xr is present and isSessionSupported returns true for ar', async () => {
    xrSystemMock.isSessionSupported.mockResolvedValueOnce(true)
    const { toJson } = await render(<XRButton mode="AR" />)
    const tree = toJson()
    expect(tree).toMatchInlineSnapshot(`
      <button
        onClick={[Function]}
      >
        Enter AR
      </button>
    `)
  })
})
import * as React from 'react'
import * as THREE from 'three'
import { useThree, useFrame } from '@react-three/fiber'
import { useXR } from './XR'
import { XRController } from './XRController'
import { useXREvent, XREvent, XRControllerEvent } from './XREvents'
import { useCallbackRef, useIsomorphicLayoutEffect } from './utils'

export interface XRInteractionEvent {
  intersection?: THREE.Intersection
  intersections: THREE.Intersection[]
  target: XRController
}

export type XRInteractionType =
  | 'onHover'
  | 'onBlur'
  | 'onSelect'
  | 'onSelectEnd'
  | 'onSelectStart'
  | 'onSelectMissed'
  | 'onSqueeze'
  | 'onSqueezeEnd'
  | 'onSqueezeStart'
  | 'onSqueezeMissed'
  | 'onMove'

export type XRInteractionHandler = (event: XRInteractionEvent) => void

const tempMatrix = new THREE.Matrix4()

export function InteractionManager({ children }: { children: React.ReactNode }) {
  const events = useThree((state) => state.events)
  const get = useThree((state) => state.get)
  const raycaster = useThree((state) => state.raycaster)
  const controllers = useXR((state) => state.controllers)
  const interactions = useXR((state) => state.interactions)
  const hoverState = useXR((state) => state.hoverState)
  const hasInteraction = useXR((state) => state.hasInteraction)
  const getInteraction = useXR((state) => state.getInteraction)

  const intersect = React.useCallback(
    (controller: THREE.Object3D) => {
      const objects = Array.from(interactions.keys())
      tempMatrix.identity().extractRotation(controller.matrixWorld)
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld)
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix)

      return raycaster.intersectObjects(objects, true)
    },
    [interactions, raycaster]
  )

  // Trigger hover and blur events
  useFrame(() => {
    if (interactions.size === 0) return

    for (const target of controllers) {
      if (!target.inputSource?.handedness) {
        return
      }
      const hovering = hoverState[target.inputSource.handedness]
      const hits = new Set()
      let intersections = intersect(target.controller)

      if (events.filter) {
        // https://github.com/mrdoob/three.js/issues/16031
        // Allow custom userland intersect sort order
        intersections = events.filter(intersections, get())
      } else {
        // Otherwise, filter to first hit
        const hit = intersections.find((i) => i?.object)
        if (hit) intersections = [hit]
      }

      for (const intersection of intersections) {
        let eventObject: THREE.Object3D | null = intersection.object

        while (eventObject) {
          if (hasInteraction(eventObject, 'onHover') && !hovering.has(eventObject)) {
            const handlers = getInteraction(eventObject, 'onHover')!
            for (const handler of handlers) {
              handler({ target, intersection, intersections })
            }
          }

          const moveHandlers = getInteraction(eventObject, 'onMove')
          moveHandlers?.forEach((handler) => handler({ target, intersection, intersections }))

          hovering.set(eventObject, intersection)
          hits.add(eventObject.id)
          eventObject = eventObject.parent
        }
      }

      // Trigger blur on all the object that were hovered in the previous frame
      // but missed in this one
      for (const eventObject of hovering.keys()) {
        if (!hits.has(eventObject.id)) {
          hovering.delete(eventObject)

          const handlers = getInteraction(eventObject, 'onBlur')
          if (!handlers) continue

          for (const handler of handlers) {
            handler({ target, intersections })
          }
        }
      }
    }
  })

  const triggerEvent = React.useCallback(
    (interaction: XRInteractionType) => (e: XREvent<XRControllerEvent>) => {
      if (!e.target.inputSource?.handedness) {
        return
      }
      const hovering = hoverState[e.target.inputSource.handedness]
      const intersections = Array.from(new Set(hovering.values()))

      interactions.forEach((handlers, object) => {
        if (hovering.has(object)) {
          if (!handlers[interaction]) return

          for (const handler of handlers[interaction]) {
            handler.current?.({ target: e.target, intersection: hovering.get(object), intersections })
          }
        } else {
          if (interaction === 'onSelect' && handlers['onSelectMissed']) {
            for (const handler of handlers['onSelectMissed']) {
              handler.current?.({ target: e.target, intersections })
            }
          } else if (interaction === 'onSqueeze' && handlers['onSqueezeMissed']) {
            for (const handler of handlers['onSqueezeMissed']) {
              handler.current?.({ target: e.target, intersections })
            }
          }
        }
      })
    },
    [hoverState, interactions]
  )

  useXREvent('select', triggerEvent('onSelect'))
  useXREvent('selectstart', triggerEvent('onSelectStart'))
  useXREvent('selectend', triggerEvent('onSelectEnd'))
  useXREvent('squeeze', triggerEvent('onSqueeze'))
  useXREvent('squeezeend', triggerEvent('onSqueezeEnd'))
  useXREvent('squeezestart', triggerEvent('onSqueezeStart'))

  return <>{children}</>
}

export function useInteraction(ref: React.RefObject<THREE.Object3D>, type: XRInteractionType, handler?: XRInteractionHandler) {
  const addInteraction = useXR((state) => state.addInteraction)
  const removeInteraction = useXR((state) => state.removeInteraction)
  const handlerRef = useCallbackRef(handler)

  useIsomorphicLayoutEffect(() => {
    const target = ref.current
    if (!target || !handlerRef.current) return

    addInteraction(target, type, handlerRef as React.RefObject<XRInteractionHandler>)

    return () => removeInteraction(target, type, handlerRef as React.RefObject<XRInteractionHandler>)
  }, [ref, type, addInteraction, removeInteraction])
}

export interface InteractiveProps {
  onHover?: XRInteractionHandler
  onBlur?: XRInteractionHandler
  onSelectStart?: XRInteractionHandler
  onSelectEnd?: XRInteractionHandler
  onSelectMissed?: XRInteractionHandler
  onSelect?: XRInteractionHandler
  onSqueezeStart?: XRInteractionHandler
  onSqueezeEnd?: XRInteractionHandler
  onSqueezeMissed?: XRInteractionHandler
  onSqueeze?: XRInteractionHandler
  onMove?: XRInteractionHandler
  children: React.ReactNode
}
export const Interactive = React.forwardRef<THREE.Group, InteractiveProps>(function Interactive(
  {
    onHover,
    onBlur,
    onSelectStart,
    onSelectEnd,
    onSelectMissed,
    onSelect,
    onSqueezeStart,
    onSqueezeEnd,
    onSqueezeMissed,
    onSqueeze,
    onMove,
    children
  }: InteractiveProps,
  passedRef
) {
  const ref = React.useRef<THREE.Group>(null!)
  React.useImperativeHandle(passedRef, () => ref.current)

  useInteraction(ref, 'onHover', onHover)
  useInteraction(ref, 'onBlur', onBlur)
  useInteraction(ref, 'onSelectStart', onSelectStart)
  useInteraction(ref, 'onSelectEnd', onSelectEnd)
  useInteraction(ref, 'onSelectMissed', onSelectMissed)
  useInteraction(ref, 'onSelect', onSelect)
  useInteraction(ref, 'onSqueezeStart', onSqueezeStart)
  useInteraction(ref, 'onSqueezeEnd', onSqueezeEnd)
  useInteraction(ref, 'onSqueezeMissed', onSqueezeMissed)
  useInteraction(ref, 'onSqueeze', onSqueeze)
  useInteraction(ref, 'onMove', onMove)

  return <group ref={ref}>{children}</group>
})

export interface RayGrabProps extends InteractiveProps {}
export const RayGrab = React.forwardRef<THREE.Group, RayGrabProps>(function RayGrab(
  { onSelectStart, onSelectEnd, children, ...rest },
  forwardedRef
) {
  const grabbingController = React.useRef<THREE.Object3D>()
  const groupRef = React.useRef<THREE.Group>(null!)
  const previousTransform = React.useMemo(() => new THREE.Matrix4(), [])
  React.useImperativeHandle(forwardedRef, () => groupRef.current)

  useFrame(() => {
    const controller = grabbingController.current
    const group = groupRef.current
    if (!controller) return

    group.applyMatrix4(previousTransform)
    group.applyMatrix4(controller.matrixWorld)
    group.updateMatrixWorld()

    previousTransform.copy(controller.matrixWorld).invert()
  })

  return (
    <Interactive
      ref={groupRef}
      onSelectStart={(e) => {
        grabbingController.current = e.target.controller
        previousTransform.copy(e.target.controller.matrixWorld).invert()
        onSelectStart?.(e)
      }}
      onSelectEnd={(e) => {
        if (e.target.controller === grabbingController.current) {
          grabbingController.current = undefined
        }
        onSelectEnd?.(e)
      }}
      {...rest}
    >
      {children}
    </Interactive>
  )
})

export type HitTestCallback = (hitMatrix: THREE.Matrix4, hit: XRHitTestResult) => void

export function useHitTest(hitTestCallback: HitTestCallback) {
  const session = useXR((state) => state.session)
  const hitTestSource = React.useRef<XRHitTestSource | undefined>()
  const hitMatrix = React.useMemo(() => new THREE.Matrix4(), [])

  useIsomorphicLayoutEffect(() => {
    if (!session) return void (hitTestSource.current = undefined)

    session.requestReferenceSpace('viewer').then(async (referenceSpace) => {
      hitTestSource.current = await session?.requestHitTestSource?.({ space: referenceSpace })
    })
  }, [session])

  useFrame((state, _, frame: XRFrame) => {
    if (!frame || !hitTestSource.current) return

    const [hit] = frame.getHitTestResults(hitTestSource.current)
    if (hit) {
      const referenceSpace = state.gl.xr.getReferenceSpace()!
      const pose = hit.getPose(referenceSpace)

      if (pose) {
        hitMatrix.fromArray(pose.transform.matrix)
        hitTestCallback(hitMatrix, hit)
      }
    }
  })
}
import * as React from 'react'
import * as THREE from 'three'
import create, { EqualityChecker, GetState, SetState, StateSelector } from 'zustand'
import { useThree } from '@react-three/fiber'
import { XRController } from './XRController'
import { InteractionManager, XRInteractionHandler, XRInteractionType } from './Interactions'
import { XREventHandler } from './XREvents'
import { uniq, useIsomorphicLayoutEffect, useCallbackRef } from './utils'
import { XRContext, XRState } from './context'

interface GlobalSessionState {
  set: SetState<GlobalSessionState>
  get: GetState<GlobalSessionState>
  session: XRSession | null
  referenceSpaceType: XRReferenceSpaceType | null
}
const globalSessionStore = create<GlobalSessionState>((set, get) => ({ set, get, session: null, referenceSpaceType: null }))

export type XRManagerEventType = 'sessionstart' | 'sessionend'
export interface XRManagerEvent {
  type: XRManagerEventType
  target: XRSession
}
export interface XRProps {
  /**
   * Enables foveated rendering. `Default is `0`
   * 0 = no foveation, full resolution
   * 1 = maximum foveation, the edges render at lower resolution
   */
  foveation?: number
  /**
   * The target framerate for the XRSystem. Smaller rates give more CPU headroom at the cost of responsiveness.
   * Recommended range is `72`-`120`. Default is unset and left to the device.
   * @note If your experience cannot effectively reach the target framerate, it will be subject to frame reprojection
   * which will halve the effective framerate. Choose a conservative estimate that balances responsiveness and
   * headroom based on your experience.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Rendering#refresh_rate_and_frame_rate
   */
  frameRate?: number
  /** Type of WebXR reference space to use. Default is `local-floor` */
  referenceSpace?: XRReferenceSpaceType
  /** Called as an XRSession is requested */
  onSessionStart?: XREventHandler<XRManagerEvent>
  /** Called after an XRSession is terminated */
  onSessionEnd?: XREventHandler<XRManagerEvent>
  /** Called when an XRSession is hidden or unfocused. */
  onVisibilityChange?: XREventHandler<XRSessionEvent>
  /** Called when available inputsources change */
  onInputSourcesChange?: XREventHandler<XRSessionEvent>
  children: React.ReactNode
}
function XRManager({
  foveation = 0,
  frameRate = undefined,
  referenceSpace = 'local-floor',
  onSessionStart,
  onSessionEnd,
  onVisibilityChange,
  onInputSourcesChange,
  children
}: XRProps) {
  const gl = useThree((state) => state.gl)
  const camera = useThree((state) => state.camera)
  const player = useXR((state) => state.player)
  const get = useXR((state) => state.get)
  const set = useXR((state) => state.set)
  const session = useXR((state) => state.session)
  const controllers = useXR((state) => state.controllers)

  const onSessionStartRef = useCallbackRef(onSessionStart)
  const onSessionEndRef = useCallbackRef(onSessionEnd)
  const onVisibilityChangeRef = useCallbackRef(onVisibilityChange)
  const onInputSourcesChangeRef = useCallbackRef(onInputSourcesChange)

  useIsomorphicLayoutEffect(() => {
    const handlers = [0, 1].map((id) => {
      const target = new XRController(id, gl)
      const onConnected = () => set((state) => ({ controllers: [...state.controllers, target] }))
      const onDisconnected = () => set((state) => ({ controllers: state.controllers.filter((it) => it !== target) }))

      target.addEventListener('connected', onConnected)
      target.addEventListener('disconnected', onDisconnected)

      return () => {
        target.removeEventListener('connected', onConnected)
        target.removeEventListener('disconnected', onDisconnected)
      }
    })

    return () => handlers.forEach((cleanup) => cleanup())
  }, [gl, set])

  useIsomorphicLayoutEffect(() => globalSessionStore.subscribe(({ session }) => set(() => ({ session }))), [gl.xr, set])

  useIsomorphicLayoutEffect(() => {
    gl.xr.setFoveation(foveation)
    set(() => ({ foveation }))
  }, [gl.xr, foveation, set])

  useIsomorphicLayoutEffect(() => {
    try {
      if (frameRate) session?.updateTargetFrameRate?.(frameRate)
    } catch (_) {
      // Framerate not supported or configurable
    }
    set(() => ({ frameRate }))
  }, [session, frameRate, set])

  useIsomorphicLayoutEffect(() => {
    const globalSessionState = globalSessionStore.getState()
    gl.xr.setReferenceSpaceType(referenceSpace)
    set(() => ({ referenceSpace }))
    globalSessionState.set({ referenceSpaceType: referenceSpace })
  }, [gl.xr, referenceSpace, set])

  useIsomorphicLayoutEffect(() => {
    if (!session) return void gl.xr.setSession(null!)

    const handleSessionStart = (nativeEvent: XRManagerEvent) => {
      set(() => ({ isPresenting: true }))
      onSessionStartRef.current?.({ nativeEvent: { ...nativeEvent, target: session }, target: session })
    }
    const handleSessionEnd = (nativeEvent: XRManagerEvent) => {
      set(() => ({ isPresenting: false, session: null }))
      globalSessionStore.setState(() => ({ session: null }))
      onSessionEndRef.current?.({ nativeEvent: { ...nativeEvent, target: session }, target: session })
    }
    const handleVisibilityChange = (nativeEvent: XRSessionEvent) => {
      onVisibilityChangeRef.current?.({ nativeEvent, target: session })
    }
    const handleInputSourcesChange = (nativeEvent: XRInputSourceChangeEvent) => {
      const isHandTracking = Object.values(session.inputSources).some((source) => source.hand)
      set(() => ({ isHandTracking }))
      onInputSourcesChangeRef.current?.({ nativeEvent, target: session })
    }

    gl.xr.addEventListener('sessionstart', handleSessionStart)
    gl.xr.addEventListener('sessionend', handleSessionEnd)
    session.addEventListener('visibilitychange', handleVisibilityChange)
    session.addEventListener('inputsourceschange', handleInputSourcesChange)

    gl.xr.setSession(session).then(() => {
      // on setSession, three#WebXRManager resets foveation to 1
      // so foveation set needs to happen after it
      gl.xr.setFoveation(get().foveation)
    })

    return () => {
      gl.xr.removeEventListener('sessionstart', handleSessionStart)
      gl.xr.removeEventListener('sessionend', handleSessionEnd)
      session.removeEventListener('visibilitychange', handleVisibilityChange)
      session.removeEventListener('inputsourceschange', handleInputSourcesChange)
    }
  }, [session, gl.xr, set, get])

  return (
    <InteractionManager>
      <primitive object={player}>
        <primitive object={camera} />
        {controllers.map((controller) => (
          <primitive key={controller.index} object={controller} />
        ))}
      </primitive>
      {children}
    </InteractionManager>
  )
}

export function XR(props: XRProps) {
  const store = React.useMemo(
    () =>
      create<XRState>((set, get) => ({
        set,
        get,

        controllers: [],
        isPresenting: false,
        isHandTracking: false,
        player: new THREE.Group(),
        session: null,
        foveation: 0,
        referenceSpace: 'local-floor',

        hoverState: {
          left: new Map(),
          right: new Map(),
          none: new Map()
        },
        interactions: new Map(),
        hasInteraction(object: THREE.Object3D, eventType: XRInteractionType) {
          return !!get()
            .interactions.get(object)
            ?.[eventType].some((handlerRef) => handlerRef.current)
        },
        getInteraction(object: THREE.Object3D, eventType: XRInteractionType) {
          return get()
            .interactions.get(object)
            ?.[eventType].reduce((result, handlerRef) => {
              if (handlerRef.current) {
                result.push(handlerRef.current)
              }
              return result
            }, [] as XRInteractionHandler[])
        },
        addInteraction(object: THREE.Object3D, eventType: XRInteractionType, handlerRef: React.RefObject<XRInteractionHandler>) {
          const interactions = get().interactions
          if (!interactions.has(object)) {
            interactions.set(object, {
              onHover: [],
              onBlur: [],
              onSelect: [],
              onSelectEnd: [],
              onSelectStart: [],
              onSelectMissed: [],
              onSqueeze: [],
              onSqueezeEnd: [],
              onSqueezeStart: [],
              onSqueezeMissed: [],
              onMove: []
            })
          }

          const target = interactions.get(object)!
          target[eventType].push(handlerRef)
        },
        removeInteraction(object: THREE.Object3D, eventType: XRInteractionType, handlerRef: React.RefObject<XRInteractionHandler>) {
          const target = get().interactions.get(object)
          if (target) {
            const interactionIndex = target[eventType].indexOf(handlerRef)
            if (interactionIndex !== -1) target[eventType].splice(interactionIndex, 1)
          }
        }
      })),
    []
  )

  return (
    <XRContext.Provider value={store}>
      <XRManager {...props} />
    </XRContext.Provider>
  )
}

export type XRButtonStatus = 'unsupported' | 'exited' | 'entered'
export type XRButtonUnsupportedReason = 'unknown' | 'https' | 'security'
export interface XRButtonProps extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'children' | 'onError'> {
  /** The type of `XRSession` to create */
  mode: 'AR' | 'VR' | 'inline'
  /**
   * `XRSession` configuration options
   * @see https://immersive-web.github.io/webxr/#feature-dependencies
   */
  sessionInit?: XRSessionInit
  /** Whether this button should only enter an `XRSession`. Default is `false` */
  enterOnly?: boolean
  /** Whether this button should only exit an `XRSession`. Default is `false` */
  exitOnly?: boolean
  /** This callback gets fired if XR initialization fails. */
  onError?: (error: Error) => void
  /** React children, can also accept a callback returning an `XRButtonStatus` */
  children?: React.ReactNode | ((status: XRButtonStatus) => React.ReactNode)
}

const getSessionOptions = (
  globalStateReferenceSpaceType: XRReferenceSpaceType | null,
  sessionInit: XRSessionInit | undefined
): XRSessionInit | undefined => {
  if (!globalStateReferenceSpaceType && !sessionInit) {
    return undefined
  }

  if (globalStateReferenceSpaceType && !sessionInit) {
    return { optionalFeatures: [globalStateReferenceSpaceType] }
  }

  if (globalStateReferenceSpaceType && sessionInit) {
    return { ...sessionInit, optionalFeatures: uniq([...(sessionInit.optionalFeatures ?? []), globalStateReferenceSpaceType]) }
  }

  return sessionInit
}

export const startSession = async (sessionMode: XRSessionMode, sessionInit: XRButtonProps['sessionInit']) => {
  const xrState = globalSessionStore.getState()

  if (xrState.session) {
    console.warn('@react-three/xr: session already started, please stop it first')
    return
  }

  const options = getSessionOptions(xrState.referenceSpaceType, sessionInit)
  const session = await navigator.xr!.requestSession(sessionMode, options)
  xrState.set(() => ({ session }))
  return session
}

export const stopSession = async () => {
  const xrState = globalSessionStore.getState()

  if (!xrState.session) {
    console.warn('@react-three/xr: no session to stop, please start it first')
    return
  }

  await xrState.session.end()
  xrState.set({ session: null })
}

export const toggleSession = async (
  sessionMode: XRSessionMode,
  { sessionInit, enterOnly, exitOnly }: Pick<XRButtonProps, 'sessionInit' | 'enterOnly' | 'exitOnly'> = {}
) => {
  const xrState = globalSessionStore.getState()

  // Bail if certain toggle way is disabled
  if (xrState.session && enterOnly) return
  if (!xrState.session && exitOnly) return

  // Exit/enter session
  if (xrState.session) {
    return await stopSession()
  } else {
    return await startSession(sessionMode, sessionInit)
  }
}

const getLabel = (status: XRButtonStatus, mode: XRButtonProps['mode'], reason: XRButtonUnsupportedReason) => {
  switch (status) {
    case 'entered':
      return `Exit ${mode}`
    case 'exited':
      return `Enter ${mode}`
    case 'unsupported':
    default:
      switch (reason) {
        case 'https':
          return 'HTTPS needed'
        case 'security':
          return `${mode} blocked`
        case 'unknown':
        default:
          return `${mode} unsupported`
      }
  }
}

export const XRButton = React.forwardRef<HTMLButtonElement, XRButtonProps>(function XRButton(
  { mode, sessionInit, enterOnly = false, exitOnly = false, onClick, onError, children, ...props },
  ref
) {
  const [status, setStatus] = React.useState<XRButtonStatus>('exited')
  const [reason, setReason] = React.useState<XRButtonUnsupportedReason>('unknown')
  const label = getLabel(status, mode, reason)
  const sessionMode = (mode === 'inline' ? mode : `immersive-${mode.toLowerCase()}`) as XRSessionMode
  const onErrorRef = useCallbackRef(onError)

  useIsomorphicLayoutEffect(() => {
    if (!navigator?.xr) return void setStatus('unsupported')
    navigator.xr
      .isSessionSupported(sessionMode)
      .then((supported) => {
        if (!supported) {
          const isHttps = location.protocol === 'https:'
          setStatus('unsupported')
          setReason(isHttps ? 'unknown' : 'https')
        } else {
          setStatus('exited')
        }
      })
      .catch((error) => {
        setStatus('unsupported')
        // https://developer.mozilla.org/en-US/docs/Web/API/XRSystem/isSessionSupported#exceptions
        if ('name' in error && error.name === 'SecurityError') {
          setReason('security')
        } else {
          setReason('unknown')
        }
      })
  }, [sessionMode])

  useIsomorphicLayoutEffect(
    () =>
      globalSessionStore.subscribe((state) => {
        if (state.session) {
          setStatus('entered')
        } else if (status !== 'unsupported') {
          setStatus('exited')
        }
      }),
    [status]
  )

  const handleButtonClick = React.useCallback(
    async (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
      onClick?.(event)

      try {
        toggleSession(sessionMode, { sessionInit, enterOnly, exitOnly })
      } catch (e) {
        const onError = onErrorRef.current
        if (onError && e instanceof Error) onError(e)
        else throw e
      }
    },
    [onClick, sessionMode, sessionInit, enterOnly, exitOnly, onErrorRef]
  )

  return (
    <button {...props} ref={ref} onClick={status === 'unsupported' ? onClick : handleButtonClick}>
      {(typeof children === 'function' ? children(status) : children) ?? label}
    </button>
  )
})

const buttonStyles: any = {
  position: 'absolute',
  bottom: '24px',
  left: '50%',
  transform: 'translateX(-50%)',
  padding: '12px 24px',
  border: '1px solid white',
  borderRadius: '4px',
  background: 'rgba(0, 0, 0, 0.1)',
  color: 'white',
  font: 'normal 0.8125rem sans-serif',
  outline: 'none',
  zIndex: 99999,
  cursor: 'pointer'
}

export const ARButton = React.forwardRef<HTMLButtonElement, Omit<XRButtonProps, 'mode'>>(
  (
    {
      style = buttonStyles,
      sessionInit = {
        // @ts-ignore
        domOverlay: typeof document !== 'undefined' ? { root: document.body } : undefined,
        optionalFeatures: ['hit-test', 'dom-overlay', 'dom-overlay-for-handheld-ar']
      },
      children,
      ...rest
    },
    ref
  ) => (
    <XRButton {...rest} ref={ref} mode="AR" style={style} sessionInit={sessionInit}>
      {children}
    </XRButton>
  )
)

export const VRButton = React.forwardRef<HTMLButtonElement, Omit<XRButtonProps, 'mode'>>(
  (
    {
      style = buttonStyles,
      sessionInit = { optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'layers'] },
      children,
      ...rest
    },
    ref
  ) => (
    <XRButton {...rest} ref={ref} mode="VR" style={style} sessionInit={sessionInit}>
      {children}
    </XRButton>
  )
)

export function useXR<T = XRState>(
  selector: StateSelector<XRState, T> = (state) => state as unknown as T,
  equalityFn?: EqualityChecker<T>
) {
  const store = React.useContext(XRContext)
  if (!store) throw new Error('useXR must be used within an <XR /> component!')
  return store(selector, equalityFn)
}

export function useController(handedness: XRHandedness) {
  const controllers = useXR((state) => state.controllers)
  const controller = React.useMemo(
    () => controllers.find(({ inputSource }) => inputSource?.handedness && inputSource.handedness === handedness),
    [handedness, controllers]
  )

  return controller
}
export * from './Controllers'
export * from './Hands'
export * from './Interactions'
export * from './XR'
export * from './XRController'
export * from './XREvents'
export * from './XRControllerModelFactory'
export * from './Teleportation'
export { type XRState } from './context'import React, { ReactNode } from 'react'
import { create, StoreApi } from 'zustand'
import { useIsomorphicLayoutEffect } from './utils'

type Props = { children: React.ReactNode }

type State = {
  current: Array<React.ReactNode>
  version: number
  set: StoreApi<State>['setState']
}

export default function tunnel() {
  const useStore = create<State>((set) => ({
    current: new Array<ReactNode>(),
    version: 0,
    set,
  }))

  return {
    In: ({ children }: Props) => {
      const set = useStore((state) => state.set)
      const version = useStore((state) => state.version)

      /* When this component mounts, we increase the store's version number.
      This will cause all existing rats to re-render (just like if the Out component
      were mapping items to a list.) The re-rendering will cause the final 
      order of rendered components to match what the user is expecting. */
      useIsomorphicLayoutEffect(() => {
        set((state) => ({
          version: state.version + 1,
        }))
      }, [])

      /* Any time the children _or_ the store's version number change, insert
      the specified React children into the list of rats. */
      useIsomorphicLayoutEffect(() => {
        set(({ current }) => ({
          current: [...current, children],
        }))

        return () =>
          set(({ current }) => ({
            current: current.filter((c) => c !== children),
          }))
      }, [children, version])

      return null
    },

    Out: () => {
      const current = useStore((state) => state.current)
      return <>{current}</>
    },
  }
}
import '@testing-library/jest-dom'
import { fireEvent, render, screen } from '@testing-library/react'
import React from 'react'
import tunnel from '../src'

describe('tunnelrat', () => {
  it('transports the children of In into Out', () => {
    const t = tunnel()

    const Outlet = () => (
      <ul>
        <t.Out />
      </ul>
    )

    const Inlets = () => (
      <div>
        <t.In>
          <li>One</li>
        </t.In>
      </div>
    )

    const { container } = render(
      <>
        <Outlet />
        <Inlets />
      </>
    )

    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
        </ul>
        <div />
      </div>
    `)
  })

  it('can handle multiple children', () => {
    const t = tunnel()

    const Outlet = () => (
      <ul>
        <t.Out />
      </ul>
    )

    const Inlets = () => (
      <div>
        <t.In>
          <li>One</li>
        </t.In>
        <t.In>
          <li>Two</li>
        </t.In>
      </div>
    )

    const { container } = render(
      <>
        <Outlet />
        <Inlets />
      </>
    )

    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
          <li>
            Two
          </li>
        </ul>
        <div />
      </div>
    `)
  })

  it('retains the expected order of multiple children after un- and remounts', () => {
    const t = tunnel()

    const Rat = ({ name }: { name: string }) => {
      const [visible, setVisible] = React.useState(true)

      return (
        <div>
          <button onClick={() => setVisible(!visible)}>Toggle {name}</button>
          {visible ? (
            <t.In>
              <li>{name}</li>
            </t.In>
          ) : null}
        </div>
      )
    }

    const Outlet = () => (
      <ul>
        <t.Out />
      </ul>
    )

    const Inlets = () => (
      <div>
        <Rat name="One" />
        <Rat name="Two" />
        <Rat name="Three" />
      </div>
    )

    const { container } = render(
      <>
        <Outlet />
        <Inlets />
      </>
    )

    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
          <li>
            Two
          </li>
          <li>
            Three
          </li>
        </ul>
        <div>
          <div>
            <button>
              Toggle 
              One
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Two
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Three
            </button>
          </div>
        </div>
      </div>
    `)

    /* Remove the middle rat */
    fireEvent.click(screen.getByText('Toggle Two'))

    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
          <li>
            Three
          </li>
        </ul>
        <div>
          <div>
            <button>
              Toggle 
              One
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Two
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Three
            </button>
          </div>
        </div>
      </div>
    `)

    /* Re-add it */
    fireEvent.click(screen.getByText('Toggle Two'))

    /* The "Two" rat gets re-added, and at the top of the list. */
    expect(container).toMatchInlineSnapshot(`
      <div>
        <ul>
          <li>
            One
          </li>
          <li>
            Two
          </li>
          <li>
            Three
          </li>
        </ul>
        <div>
          <div>
            <button>
              Toggle 
              One
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Two
            </button>
          </div>
          <div>
            <button>
              Toggle 
              Three
            </button>
          </div>
        </div>
      </div>
    `)
  })
})
import * as React from 'react'
import type ReactReconciler from 'react-reconciler'

/**
 * An SSR-friendly useLayoutEffect.
 *
 * React currently throws a warning when using useLayoutEffect on the server.
 * To get around it, we can conditionally useEffect on the server (no-op) and
 * useLayoutEffect elsewhere.
 *
 * @see https://github.com/facebook/react/issues/14927
 */
const useIsomorphicLayoutEffect =
  typeof window !== 'undefined' && (window.document?.createElement || window.navigator?.product === 'ReactNative')
    ? React.useLayoutEffect
    : React.useEffect

/**
 * Represents a react-internal Fiber node.
 */
export type Fiber<T = any> = Omit<ReactReconciler.Fiber, 'stateNode'> & { stateNode: T }

/**
 * Represents a {@link Fiber} node selector for traversal.
 */
export type FiberSelector<T = any> = (
  /** The current {@link Fiber} node. */
  node: Fiber<T | null>,
) => boolean | void

/**
 * Traverses up or down a {@link Fiber}, return `true` to stop and select a node.
 */
export function traverseFiber<T = any>(
  /** Input {@link Fiber} to traverse. */
  fiber: Fiber | undefined,
  /** Whether to ascend and walk up the tree. Will walk down if `false`. */
  ascending: boolean,
  /** A {@link Fiber} node selector, returns the first match when `true` is passed. */
  selector: FiberSelector<T>,
): Fiber<T> | undefined {
  if (!fiber) return
  if (selector(fiber) === true) return fiber

  let child = ascending ? fiber.return : fiber.child
  while (child) {
    const match = traverseFiber(child, ascending, selector)
    if (match) return match

    child = ascending ? null : child.sibling
  }
}

// In development, React will warn about using contexts between renderers.
// Hide the warning because its-fine fixes this issue
// https://github.com/facebook/react/pull/12779
function wrapContext<T>(context: React.Context<T>): React.Context<T> {
  try {
    return Object.defineProperties(context, {
      _currentRenderer: {
        get() {
          return null
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null
        },
        set() {},
      },
    })
  } catch (_) {
    return context
  }
}

const error = console.error
console.error = function () {
  const message = [...arguments].join('')
  if (message?.startsWith('Warning:') && message.includes('useContext')) {
    console.error = error
    return
  }

  return error.apply(this, arguments as any)
}

const FiberContext = wrapContext(React.createContext<Fiber>(null!))

/**
 * A react-internal {@link Fiber} provider. This component binds React children to the React Fiber tree. Call its-fine hooks within this.
 */
export class FiberProvider extends React.Component<{ children?: React.ReactNode }> {
  private _reactInternals!: Fiber

  render() {
    return <FiberContext.Provider value={this._reactInternals}>{this.props.children}</FiberContext.Provider>
  }
}

/**
 * Returns the current react-internal {@link Fiber}. This is an implementation detail of [react-reconciler](https://github.com/facebook/react/tree/main/packages/react-reconciler).
 */
export function useFiber(): Fiber<null> | undefined {
  const root = React.useContext(FiberContext)
  if (root === null) throw new Error('its-fine: useFiber must be called within a <FiberProvider />!')

  const id = React.useId()
  const fiber = React.useMemo(() => {
    for (const maybeFiber of [root, root?.alternate]) {
      if (!maybeFiber) continue
      const fiber = traverseFiber<null>(maybeFiber, false, (node) => {
        let state = node.memoizedState
        while (state) {
          if (state.memoizedState === id) return true
          state = state.next
        }
      })
      if (fiber) return fiber
    }
  }, [root, id])

  return fiber
}

/**
 * Represents a react-reconciler container instance.
 */
export interface ContainerInstance<T = any> {
  containerInfo: T
}

/**
 * Returns the current react-reconciler container info passed to {@link ReactReconciler.Reconciler.createContainer}.
 *
 * In react-dom, a container will point to the root DOM element; in react-three-fiber, it will point to the root Zustand store.
 */
export function useContainer<T = any>(): T | undefined {
  const fiber = useFiber()
  const root = React.useMemo(
    () => traverseFiber<ContainerInstance<T>>(fiber, true, (node) => node.stateNode?.containerInfo != null),
    [fiber],
  )

  return root?.stateNode.containerInfo
}

/**
 * Returns the nearest react-reconciler child instance or the node created from {@link ReactReconciler.HostConfig.createInstance}.
 *
 * In react-dom, this would be a DOM element; in react-three-fiber this would be an instance descriptor.
 */
export function useNearestChild<T = any>(
  /** An optional element type to filter to. */
  type?: keyof JSX.IntrinsicElements,
): React.MutableRefObject<T | undefined> {
  const fiber = useFiber()
  const childRef = React.useRef<T>()

  useIsomorphicLayoutEffect(() => {
    childRef.current = traverseFiber<T>(
      fiber,
      false,
      (node) => typeof node.type === 'string' && (type === undefined || node.type === type),
    )?.stateNode
  }, [fiber])

  return childRef
}

/**
 * Returns the nearest react-reconciler parent instance or the node created from {@link ReactReconciler.HostConfig.createInstance}.
 *
 * In react-dom, this would be a DOM element; in react-three-fiber this would be an instance descriptor.
 */
export function useNearestParent<T = any>(
  /** An optional element type to filter to. */
  type?: keyof JSX.IntrinsicElements,
): React.MutableRefObject<T | undefined> {
  const fiber = useFiber()
  const parentRef = React.useRef<T>()

  useIsomorphicLayoutEffect(() => {
    parentRef.current = traverseFiber<T>(
      fiber,
      true,
      (node) => typeof node.type === 'string' && (type === undefined || node.type === type),
    )?.stateNode
  }, [fiber])

  return parentRef
}

export type ContextMap = Map<React.Context<any>, any> & {
  get<T>(context: React.Context<T>): T | undefined
}

/**
 * Returns a map of all contexts and their values.
 */
export function useContextMap(): ContextMap {
  const fiber = useFiber()
  const [contextMap] = React.useState(() => new Map<React.Context<any>, any>())

  // Collect live context
  contextMap.clear()
  let node = fiber
  while (node) {
    if (node.type && typeof node.type === 'object') {
      // https://github.com/facebook/react/pull/28226
      const enableRenderableContext = node.type._context === undefined && node.type.Provider === node.type
      const context = enableRenderableContext ? node.type : node.type._context
      if (context && context !== FiberContext && !contextMap.has(context)) {
        contextMap.set(context, React.useContext(wrapContext(context)))
      }
    }

    node = node.return!
  }

  return contextMap
}

/**
 * Represents a react-context bridge provider component.
 */
export type ContextBridge = React.FC<React.PropsWithChildren<{}>>

/**
 * React Context currently cannot be shared across [React renderers](https://reactjs.org/docs/codebase-overview.html#renderers) but explicitly forwarded between providers (see [react#17275](https://github.com/facebook/react/issues/17275)). This hook returns a {@link ContextBridge} of live context providers to pierce Context across renderers.
 *
 * Pass {@link ContextBridge} as a component to a secondary renderer to enable context-sharing within its children.
 */
export function useContextBridge(): ContextBridge {
  const contextMap = useContextMap()

  // Flatten context and their memoized values into a `ContextBridge` provider
  return React.useMemo(
    () =>
      Array.from(contextMap.keys()).reduce(
        (Prev, context) => (props) =>
          (
            <Prev>
              <context.Provider {...props} value={contextMap.get(context)} />
            </Prev>
          ),
        (props) => <FiberProvider {...props} />,
      ),
    [contextMap],
  )
}
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import React from 'react';
import Loader from '../../../src/components/Loader';

// Mock framer-motion to avoid animation issues in tests
vi.mock('framer-motion', () => ({
  motion: {
    div: ({ children, ...props }: any) => React.createElement('div', props, children),
    p: ({ children, ...props }: any) => React.createElement('p', props, children)
  }
}));

describe('Loader Component', () => {
  it('renders with default message', () => {
    render(React.createElement(Loader));
    
    // Check if the default loading message is displayed
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('renders with custom message', () => {
    const customMessage = 'Custom loading message';
    render(React.createElement(Loader, { message: customMessage }));
    
    // Check if the custom message is displayed
    expect(screen.getByText(customMessage)).toBeInTheDocument();
  });
});